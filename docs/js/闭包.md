---
title: 闭包
date: 2020-07-28
tags:
 - JS
categories:
 - 前端笔记
---

## 闭包
闭包指有权访问另一个函数作用域中变量的函数

简单理解就是，一个作用域可以访问另一个函数内部的局部变量

示例：
```js
function fn() {
  var num = 10;
  return function() {
    console.log(num)
  }
}

var f = fn();
f();
```
通过闭包可以延伸变量的作用范围

```js
var name = "The Window";
var object = {
  name: "My Object",
  getNameFunc:function() {
    return function() {
      return this.name;
    };
  }
};

console.log(object.getNameFunc())
```
输出: `The Window`

```js
var name = "The Window";
var object = {
  name: "My Object",
  getNameFunc:function() {
    var that = this;
    return function() {
      return that.name;
    };
  }
};

console.log(object.getNameFunc())
```
输出: `My Object`

## 代码例子
### 示例1：
```js
var test = (function(i) {
  return function() {
    alert(i *= 2);
  }
})(2);
test(5);
```
输出：`'4'`

解析：test返回的是立即执行函数function的执行结果，立即执行函数执行过程中将2作为参数赋值给i，
test(5)这里的调用的是return的function，return的function没有参数，所以参数5无效，alert(i *= 2)中i去到
上级作用域找，找到i为2，所以alert(4)，由于alert()输出的是一个字符串，所以结果为`'4'`

### 示例2：
```js
var a = 0,
    b = 0;
function A(a) {
  A = function(b) {
    alert(a + b++);
  };
  alert(a++)
}
A(1);
A(2);
```
输出：`'1'` `'4'`

解析： 首先A(1)调用function 'A(a)'，改变了全局函数A的指向，使得A变成了'A(b)'，
然后alert(a++)，输出`'1'`，此时a变为2,随后再次调用A(2)，此时的A就是'A(b)'这个function了，
所以会执行alert(a + b++)，此时传进去的2的值实际是传给形参b，所以b为2，而a在'A(b)'中没有，
就去上级作用域找，上级作用域由于有形参a，值为2，所以就是alert(4)，输出`'4'`

### 示例3：
```js
function Foo() {
  getName = function() {
    console.log(1)
  };
  return this;
}
Foo.getName = function() {
  console.log(2);
};
Foo.prototype.getName = function() {
  console.log(3);
};
var getName = function() {
  console.log(4);
};
function getName() {
  console.log(5);
} 
Foo.getName();  // 2
getName();    // 4
Foo().getName();  // 1    
getName();    // 1
new Foo.getName();  // 2
new Foo().getName();  // 3
new new Foo().getName();  // 3
```
解析：

1.变量提升

首先function Foo,全局作用域中有个Foo，Foo是一个堆，堆中有个getName => 1，代表输出1，
然后到了var getName，此时变量提升只是定义没有赋值，全局作用域中有个getName，然后是function getName，将getName => 5

2.代码执行

Foo已经变量提升，无需再执行

Foo.getName将堆中的getName =>2;

Foo.prototype.getName，prototype也是一个对象，所以Foo.prototype.getName指向的是Foo.prototype的堆

var getName将全局作用域下的getName => 4

getName已经变量提升，无需再执行

* Foo.getName()

调用Foo堆中的getName，输出2

* getName()

调用全局作用域下的getName，输出4

* Foo().getName()

先执行Foo()，再调用getName()，执行Foo()，此时全局作用域下的getName =>1,所以输出1

* getName()

再次输出全局作用域下的getName，一样还是1

* new Foo.getName()

这里需要判断优先级，成员访问和new(带参数列表)的优先级为19，new(无参数列表)的优先级为18，
如果优先级相同，则从左到右执行，此处为成员访问+new(无参数列表)

因此先执行Foo.getName()，后执行new

因此输出为2

* new Foo().getName()

这里为成员访问和new(带参数列表)，new在左，所以先执行new Foo(),再执行getName()

此时会创建一个Foo实例，Foo实例调用getName()方法，而在Foo()中没有this.getName()方法，Foo()中
的getName()方法为Window下的getName(),所以会去Foo.prototype中去寻找getName()，所以输出3

* new new Foo().getName()

有多个个new，先执行最右边的new，所以还是先执行new Foo(),此时就变为new Foo实例.getName(),
因此先执行Foo实例.getName(),再执行new，所以输出还是3
