---
title: 继承
date: 2020-11-24
tags:
 - JS
categories:
 - 前端笔记
---

### 原型链继承

```js
function Animal() {
    this.arr = [];
    this.action = "run";
}
function Person() {
    this.say = "talk";
}
Person.prototype = new Animal();
const person = new Person();
console.log(person.action, person.say); // run talk

person.arr.push(1);
const p2 = new Person();
console.log(p2.arr, p2.action); // [1] run
```

::: warning 缺点

1. 原型链继承共享实例属性，属于引用类型传值，针对父类实例引用类型属性进行修改，会影响其他子类实例
2. 不能向父类构造函数随时传递参数，很不灵活

:::

### 构造函数继承

借用构造函数继承，在执行Person构造函数的时候，子类的实例各自得到一份构造函数的副本，属于值传递，所以子类之间属性的修改互不干扰

```js
function Animal() {
    this.arr = [];
    this.action = "run";
}
function Person() {
    Animal.call(this);
}

const person = new Person();
person.arr.push(1);
console.log(person.arr, person.action); // [1] run

const p2 = new Person();
console.log(p2.arr, p2.action); // [] run
```

::: warning 缺点

1. 无法达到函数复用，因为每一个函数和属性都需要在构造函数中定义，没有形成原型链关系
2. 无法通过`instanceof`确定子类实例和父类之间的关系，因为子类的`prototype`和父类无关

:::

### 组合式继承

组合式继承模式就是原型链继承+构造函数继承

原型链继承共享属性（属性方法和属性），构造函数继承父类构造函数的实例属性

```js
function Animal() {
    this.arr = [];
    this.action = "run";
}
function Person() {
    Animal.call(this); // 借用构造函数，第一次调用父类的构造函数
}

Person.prototype = new Animal(); // 原型链继承， 第二次调用构造函数

const person = new Person();
console.log(person.action); // run
```

::: warning 缺点

调用了两次父类构造函数，生成了两份实例，一个子类实例，一个父类实例，父类实例作为prototype使用

:::

### 原型式继承

利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型

```js
function object(obj){
  function F(){}
  F.prototype = obj
  return new F()
}
```

### 寄生式继承

```js
const obj = {
  name: 'xiaoming',
  friends:['xiaohong', 'xiaoli']
}
function CreateObj(o){
  function F(){}
  F.prototype = o
  return new F()
}


const obj1 = CreateObj(o)
// 创建obj1有另一种方法，等同于
const obj2 = Object.create(o)

function CreateChild(o){
	const newobj = CreateObj(o)
  newobj.sayName = function(){
    console.log(this.name)
  }
  return newobj
}
const p1 = new CreateChild(o)
p1.sayName()
```

### 寄生组合式继承

```js
function Parent(name){
  this.name = name
  this.colors = ['red', 'yellow', 'blue']
}

Parent.prototype.sayName = function(){
  console.log(this.name)
}

function Child(name, age){
  Parent.call(this, name)
  this.age = age
}

function CreateObj(o){
  function F(){}
  F.prototype = o
  return new F()
}

function prototype(child, parent){
  const prototype = CreateObj(parent.prototype)
  prototype.constructor = child
  child.prototype = prototype
}

prototype(Child, Parent)

const child = new Child('xiaoming', 18)
console.log(child)
```

### ES6实现继承

```js
class Animal {
    constructor() {
        this.action = "run";
    }
}
class Person extends Animal {
    constructor() {
        super();
    }
}
const person = new Person();
console.log(person.action); // run
```

