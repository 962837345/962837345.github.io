---
title: 继承
date: 2020-11-24
tags:
 - JS
categories:
 - 前端笔记
---

### 原型链继承

```js
function Animal() {
    this.arr = [];
    this.action = "run";
}
function Person() {
    this.say = "talk";
}
Person.prototype = new Animal();
const person = new Person();
console.log(person.action, person.say); // run talk

person.arr.push(1);
const p2 = new Person();
console.log(p2.arr, p2.action); // [1] run
```

::: warning 缺点

1. 原型链继承共享实例属性，属于引用类型传值，针对父类实例引用类型属性进行修改，会影响其他子类实例
2. 不能向父类构造函数随时传递参数，很不灵活

:::

### 构造函数继承

借用构造函数继承，在执行Person构造函数的时候，子类的实例各自得到一份构造函数的副本，属于值传递，所以子类之间属性的修改互不干扰

```js
function Animal() {
    this.arr = [];
    this.action = "run";
}
function Person() {
    Animal.call(this);
}

const person = new Person();
person.arr.push(1);
console.log(person.arr, person.action); // [1] run

const p2 = new Person();
console.log(p2.arr, p2.action); // [] run
```

::: warning 缺点

1. 无法达到函数复用，因为每一个函数和属性都需要在构造函数中定义，没有形成原型链关系
2. 无法通过`instanceof`确定子类实例和父类之间的关系，因为子类的`prototype`和父类无关

:::

### 组合式继承

组合式继承模式就是原型链继承+构造函数继承

原型链继承共享属性（属性方法和属性），构造函数继承父类构造函数的实例属性

```js
function Animal() {
    this.arr = [];
    this.action = "run";
}
function Person() {
    Animal.call(this); // 借用构造函数，第一次调用父类的构造函数
}

Person.prototype = new Animal(); // 原型链继承， 第二次调用构造函数
Person.prototype.constructor = Animal; // 将实例的原型上的构造函数指定为当前子类的构造函数

const person = new Person();
console.log(person.action); // run
```

::: warning 缺点

调用了两次父类构造函数，生成了两份实例，一个子类实例，一个父类实例，父类实例作为prototype使用

:::

### 原型式继承

利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型

```js
function object(obj){
    function F(){
        F.prototype = obj
        return new F()
    }
}
```

### ES6实现继承

```js
class Animal {
    constructor() {
        this.action = "run";
    }
}
class Person extends Animal {
    constructor() {
        super();
    }
}
const person = new Person();
console.log(person.action); // run
```

