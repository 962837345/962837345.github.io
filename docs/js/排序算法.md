---
title: 排序算法
date: 2020-09-13
tags:
  - JS
categories:
  - 前端笔记
---

## 插入排序

插入排序思路：以从小到大排序为准，可以将数组分成两部分，有序部分和无序部分，从下标为 1 开始进行比较，默认下标 0 已有序，每次循环遍历判断，从无序部分的拿第一个去跟有序部分的最后一个进行比较，若小于则有序部分那一项向后移动一位，然后继续跟倒数第二个有序数进行比较，直到找到大于的那一项，就将该值插入，形成新的有序部分，此时有序部分就默认+1，无序部分默认-1

- 时间复杂度最优情况是数组已经有序，此时只需比较 n-1 次，时间复杂度为 O(N)
- 时间复杂度最坏情况是数组是逆序的，此时比较次数为 1+2+3+...+n-1,时间复杂度为 O(N²)
- 平均时间复杂度跟最坏情况一样也为 O(N²)
- 空间复杂度为 O(1)

```js
function insertSort(arr) {
  let temp;
  for (let i = 1; i < arr.length; i++) {
    temp = arr[i];
    let j;
    for (j = i - 1; j >= 0; j--) {
      if (temp < arr[j]) {
        // 判断如果比要插入的值大，就向后移一位
        arr[j + 1] = arr[j];
      } else {
        // 比要插入的值的小，说明已经找到正确插入位置
        break;
      }
    }
    arr[j + 1] = temp; // 将要插入的值插入
  }
  return arr;
}
```

## 选择排序

选择排序思路：将数组分为有序和无序两部分，起始有序部分长度为 0，无序部分长度为数组长度，每次循环在无序部分中选出最小的那个值，然后这个最小值跟无序部分的第一个值进行交换，使得无序部分中的第一个数为最小值，此时默认有序部分长度+1，无序部分长度-1，则这个最小数就列入到有序部分中，以此类推

- 每次比较都需要跟无序数组中的每一个数进行比较，所以总的比较次数 N = (n-1) + (n-2) +...+ 1 = n\*(n-1)/2
- 所以选择排序的时间复杂度为 O(N²)
- 空间复杂度为 O(1)

```js
function selectSort(arr) {
  let j, k; // k用于记录最小值的下标
  let temp;
  for (let i = 0; i < arr.length; i++) {
    for (j = i, k = i; j < arr.length; j++) {
      if (arr[j] < arr[k]) {
        // 跟数组中无序部分的每个数进行比较，选出最小的那个数的下标
        k = j;
      }
    }
    temp = arr[i]; // 将最小的那个数与无序部分第一个数进行交换
    arr[i] = arr[k];
    arr[k] = temp;
  }
  return arr;
}
```

## 冒泡排序

冒泡排序思路：每次循环都进行两两比较，从最后一个元素开始，如果前面的大于后面的，就交换，这样遍历一轮就会将最小的数冒泡到最前面，依次循环；优化：使用 flag 作为标记，初始值为 false，每次有进行交换就置 flag 为 true，每次遍历后就看 flag 是否为 false，如果为 false 则说明后面需要遍历的已经为有序了，直接结束遍历

- 如果一开始就是正序的，则只需扫描一遍就可完成排序，所以最好的时间复杂度为 O(N)
- 如果一开始是逆序的，需要 n-1 次排序，每次排序需要 n-i 次比较，而每次都需要交换 3 次，所以最坏的时间复杂度为 O(N²)
- 平均时间复杂度为 O(N²)

```js
function bubbleSort(arr) {
  let temp;
  let flag;
  for (let i = 0; i < arr.length - 1; i++) {
    flag = false; // 设置标志位，当有交换发生时置为true，当没有发生交换时说明剩下的数组已经是有序了，无需再比较，直接结束
    for (let j = arr.length - 1; j > i; j--) {
      // 每次循环遍历将最小值冒泡到最前面
      if (arr[j] < arr[j - 1]) {
        temp = arr[j];
        arr[j] = arr[j - 1];
        arr[j - 1] = temp;
        flag = true;
      }
    }
    if (!flag) {
      break;
    }
  }
  return arr;
}
```

## 快速排序

快速排序思路：快速排序的核心思想是分治法，初始先设置一个基准值，一般默认为数组中第一个元素，以基准值为准，左边放比基准值小的元素，右边放比基准值大的元素。

首先从数组最右边开始找，找到一个比基准值小的数，就将这个数替换到基准值的位置,同时 i++(即`arr[i++] = arr[j]`)，然后从左边开始找，找到一个比基准值大的数，将这个数替换到刚才上一个被找到的位置，同时 j--(即`arr[j--] = arr[i]`),反复判断直到 i<j 为止，此时基准值就会排列在数组中间，基准值左边的数比基准值小，基准值右边的值比基准值大；随后就是递归调用，直到全部有序

- 最优情况下时间复杂度 O(nlogn)
- 最坏情况下(有序)时间复杂度 O(N²)
- 平均时间复杂度 O(nlogn)

```js
function quickSort(arr, l, r) {
  if (l < r) {
    let i = l;
    let j = r;
    let x = arr[l];
    while (i < j) {
      while (i < j && arr[j] > x) j--;
      if (i < j) arr[i++] = arr[j];
      while (i < j && arr[i] < x) i++;
      if (i < j) arr[j--] = arr[i];
    }
    arr[i] = x;
    quickSort(arr, l, i - 1);
    quickSort(arr, i + 1, r);
  }
  return arr;
}
```

## 希尔排序

希尔排序思路：希尔排序实质是对插入排序的改进版本，希尔排序通过分组，将一个数组分成若干个小数组，小数组中使用插入排序进行排序，使得每次排序都能得到一定程度的有序，然后分组数量减半，继续使用插入排序进行排序，直到分组成为一组，此时就是正常的插入排序，但是由于之前的排序使得数组已经接近有序，所以再次使用插入排序时效率比较高，其利用的是插入排序适合数量少，相对有序的数组的特点

- 最优情况下时间复杂度为 O(nlogn)
- 最坏情况下时间复杂度为 O(N²)
- 平均情况下时间复杂度为 O(nlogn)

```js
function shellSort(arr) {
  let length = arr.length;
  for (let i = Math.floor(length / 2); i > 0; i = Math.floor(i / 2)) {
    for (let j = 0; j < i; j++) {
      for (let k = j + i; k < length; k = k + i) {
        let temp = arr[k];
        let m;
        for (m = k - i; m >= 0 && arr[m] > temp; m = m - i) {
          arr[m + i] = arr[m];
        }
        arr[m + i] = temp;
      }
    }
  }
  return arr;
}
```

## 归并排序

归并排序思路：归并排序实质是采用分治法的思想，每次将数组分解成两部分，不断递归分解，分解到数组只有两个元素时，进行排序，使得每个小数组都有序，则整个大数组部分有序，再进行合并，将两个小数组合成一个新数组，进行排序，再将新数组合成成为更大的数组进行排序

- 最优时间复杂度 O(nlogn)
- 最坏时间复杂度 O(nlogn)
- 平均时间复杂度 O(nlogn)

```js
function mergeSort(arr) {
  let len = arr.length;
  if (len < 2) {
    return arr;
  }
  let middle = Math.floor(len / 2);
  let left = arr.slice(0, middle);
  let right = arr.slice(middle, len);
  return merge(mergeSort(left), mergeSort(right));
}
function merge(left, right) {
  let result = [];
  let i = 0,
    j = 0,
    k = 0;
  while (i < left.length && j < right.length) {
    if (left[i] > right[j]) {
      result[k] = right[j];
      j++;
      k++;
    } else {
      result[k] = left[i];
      i++;
      k++;
    }
  }
  while (i < left.length) {
    result[k] = left[i];
    i++;
    k++;
  }
  while (j < right.length) {
    result[k] = right[j];
    j++;
    k++;
  }
  return result;
}
```

## 堆排序

堆排序思路:从第一个非叶子节点开始，从下至上，从右至左，堆每一个非叶子节点左 shiftDown 操作，shiftDown 操作是构建一个大顶堆，将当前结点与子节点比较，获取数值大的作为堆顶，循环后，根结点就是最大的数值，然后再将根节点与最后一个结点交换，然后重新构建大顶堆，再继续跟倒数第二个数进行交换，反复此步骤，直到排序完成

- 堆的时间复杂度为 O(nlogn)

```js
function swap(arr, i, j) {
  let temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
  return arr;
}
function shiftDown(arr, i, length) {
  let temp;
  for (let j = 2 * i + 1; j < length; j = 2 * j + 1) {
    temp = arr[i];
    if (j + 1 < length && arr[j] < arr[j + 1]) {
      j++;
    }
    if (temp < arr[j]) {
      arr = swap(arr, i, j);
      i = j;
    } else {
      break;
    }
  }
  return arr;
}
function heapSort(arr) {
  for (let i = Math.floor(arr.length / 2 - 1); i >= 0; i--) {
    arr = shiftDown(arr, i, arr.length);
  }
  for (let i = arr.length - 1; i >= 0; i--) {
    arr = swap(arr, 0, i);
    arr = shiftDown(arr, 0, i);
  }
  return arr;
}
```
