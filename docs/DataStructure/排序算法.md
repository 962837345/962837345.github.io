---
title: 排序算法
date: 2024-01-014
tags:
 - 数据结构
categories:
 - 数据结构
---


## 排序算法

### 冒泡排序
对两个相邻的元素进行比较，第一个比第二个大就进行交换，对每一个相邻的元素都进行比较，到最后的元素就会是最大的那个数

**时间复杂度（平均）O(n²)**

```py
def bubble_sort(need_sorted_list: list) -> list:
    """ 冒泡排序 """
    for i in range(len(need_sorted_list) - 1):
        for j, num1 in enumerate(need_sorted_list):
             if j < len(need_sorted_list) - 1 - i:
                 num2 = need_sorted_list[j + 1]
                 if num1 > num2:
                     temp_num = need_sorted_list[j]
                     need_sorted_list[j] = num2
                     need_sorted_list[j + 1] = temp_num
    return need_sorted_list
```

### 选择排序
将列表分类成有序区和无序区，起始的有序区为空，在列表中寻找最大（最小）的元素，将该元素加到有序区中

**时间复杂度（平均）O(n²)**
```py
def selection_sort(need_sorted_list: list) -> list:
    """ 选择排序 """
    
    # 思路实现
    ordered_list = []
    for _ in range(len(need_sorted_list)):
        max_num = max(need_sorted_list)
        need_sorted_list.remove(max_num)
        ordered_list.append(max_num)
    return ordered_list
```
```py
def selection_sort(need_sorted_list: list) -> list:
    """ 选择排序 """
   
    # 索引实现
    for i in range(len(need_sorted_list) - 1):
        min_idx = i
        for j in range(i + 1, len(need_sorted_list)):
            if need_sorted_list[j] > need_sorted_list[min_idx]:
                min_idx = j
        
        if i != min_idx:
            temp_num = need_sorted_list[i]
            need_sorted_list[i] = need_sorted_list[min_idx]
            need_sorted_list[min_idx] = temp_num
```

### 插入排序
将列表分为有序区和无序区，有序区默认拥有第一个元素，无序区为第二个以及后续的元素。每次循环在无序区中取出第一个元素j，与有序区从后往前进行比较，（从小到大排序）若小于则有序区比较的元素往后挪，直到大于或等于时，将元素j插入当前比较位置后面
**时间复杂度（平均）O(n²)**

```py
def insert_sort(need_sorted_list: list) -> list:
    """ 插入排序 """
    for i in range(1, len(need_sorted_list)):
        temp_num = need_sorted_list[i]
        cur_idx = i
        for j in range(i - 1, -1, -1):
            cur_num = need_sorted_list[j]         
            if temp_num < cur_num:
                need_sorted_list[j+1] = need_sorted_list[j]
                cur_idx = j
            else:
                break
        
        need_sorted_list[cur_idx] = temp_num
    return need_sorted_list
```
```py
def insert_sort(need_sorted_list: list) -> list:
    """ 插入排序 """
    for i in range(1, len(need_sorted_list)):
        pre_index = i - 1
        current = need_sorted_list[i]
        while(pre_index >= 0 and need_sorted_list[pre_index] > current):
            need_sorted_list[pre_index + 1] = need_sorted_list[pre_index]
            pre_index -= 1
        need_sorted_list[pre_index + 1] = current
    return need_sorted_list
```

### 希尔排序
核心思路是将排序列表分成若干个子列表分别进行插入排序
选择增量gap = len / 2, 缩小增量继续以gap = gap / 2的方式，这种增量选择我们可以用一个序列来表示{n/2, (n/2)/2, ..., 2, 1}，称为增量序列，也被称为希尔增量

**时间复杂度（平均）O(n^1.3)**

```py
def shell_sort(need_sorted_list: list) -> list:
    """ 希尔排序 """
    gap = int(len(need_sorted_list) / 2)
    while(gap > 0):
        for i in range(gap, len(need_sorted_list)):
            j = i
            temp_num = need_sorted_list[i]
            if temp_num < need_sorted_list[j - gap]:
                while ((j - gap) >= 0) and need_sorted_list[j - gap] > temp_num:
                    need_sorted_list[j] = need_sorted_list[j - gap]
                    j = j - gap
                need_sorted_list[j] = temp_num
        gap = int(gap / 2)
    return need_sorted_list
```

### 快速排序
采用分治的思想，核心思路是找到一个数字作为基准数，一般使用第一个数字作为基准数。然后把列表中小于基准数的元素移动到左边，把大于基准数的元素移到右边，这样左右两个分区就相对有序。再继续递归左右两个分区，最终就能达到有序。

**时间复杂度（平均）O(nlogn)**

```py
def quick_sort(need_sorted_list: list, start_idx: int, end_idx: int) -> list:
    """ 快速排序 """
    # 小于等于一个元素return
    if end_idx - start_idx <= 1:
        return
    pivot_idx = partition(need_sorted_list, start_idx, end_idx)
    quick_sort(need_sorted_list, start_idx, pivot_idx - 1)
    quick_sort(need_sorted_list, pivot_idx + 1, end_idx) 

def partition(need_sorted_list: list, start_idx: int, end_idx: int) -> int:
    pivot_idx = start_idx
    pivot_value = need_sorted_list[start_idx]
    while(start_idx < end_idx):
        # 找到比基准值小的索引
        while(start_idx < end_idx and pivot_value <= need_sorted_list[end_idx]):
            end_idx -= 1
       
       # 找到比基准值大的索引
        while(start_idx < end_idx and pivot_value >= need_sorted_list[start_idx]):
            start_idx += 1

        if start_idx < end_idx:
            swap(need_sorted_list, start_idx, end_idx)

    swap(need_sorted_list, pivot_idx, end_idx)

    return start_idx

def swap(need_swaped_list: list, i: int, j: int):
    temp_value = need_swaped_list[i]
    need_swaped_list[i] = need_swaped_list[j]
    need_swaped_list[j] = temp_value
```

### 归并排序

采用分治的思路，将列表分成多个子序列，使其每个子序列内部有序后，子序列再两两合并使其有序，最终合并得到一个有序的列表

**时间复杂度（平均）O(nlogn)**


```py
def merge(left: list, right: list) -> list:
    left_idx = 0
    right_idx = 0
    left_len = len(left)
    right_len = len(right)
    temp_list = []
    while(left_idx < left_len and right_idx < right_len):
        if left[left_idx] < right[right_idx]:
            temp_list.append(left[left_idx])
            left_idx += 1
        else:
            temp_list.append(right[right_idx])
            right_idx += 1

    while(left_idx < left_len):
        temp_list.append(left[left_idx])
        left_idx += 1

    while(right_idx < right_len):
        temp_list.append(right[right_idx])
        right_idx += 1

    return temp_list

def merge_sort(need_sorted_list: list) -> list:
    list_len = len(need_sorted_list)
    if list_len <= 1:
        return need_sorted_list
    m_idx = int(list_len / 2)
    return merge(merge_sort(need_sorted_list[0 : m_idx]), merge_sort(need_sorted_list[m_idx : list_len]))
```

### 堆排序

核心思路是利用堆的特性，构造最大堆后，根节点元素就是最大值。将根节点与末尾节点互换，再对n-1个元素构造最大堆，反复执行后将会得到一个有序的列表

**时间复杂度（平均）O(nlogn)**

```py
def swap(need_swaped_list: list, i: int, j: int):
    temp_value = need_swaped_list[i]
    need_swaped_list[i] = need_swaped_list[j]
    need_swaped_list[j] = temp_value

def max_heapify(need_build_list: list, start_idx: int, end_idx: int) -> list:
    temp_idx = start_idx
    child_idx = 2 * temp_idx + 1
    while(end_idx >= child_idx):
        # 有右子节点且左子节点大于右子节点(找到大的子节点)
        if (child_idx + 1 <= end_idx) and need_build_list[child_idx] < need_build_list[child_idx + 1]:
            child_idx += 1
        # 父节点比子节点都大，直接返回
        if need_build_list[temp_idx] > need_build_list[child_idx]:
            break
        else:
            swap(need_build_list, temp_idx, child_idx)
            # 将索引指向子堆，继续构造成最大堆
            temp_idx = child_idx
            child_idx = 2 * child_idx + 1

    return need_build_list

def heap_sort(need_sorted_list: list) -> list:
    """ 堆排序 """
    # 初始先构造最大堆
    for i in range(int(len(need_sorted_list) / 2), 0, -1):
        max_heapify(need_sorted_list, i, len(need_sorted_list) - 1)

    # 将最大值存放在列表末尾，对前n-1个元素构造最大堆
    for i in range(len(need_sorted_list) - 1, 1, -1):
        swap(need_sorted_list, i, 0)
        max_heapify(need_sorted_list, 0, i - 1)
    return need_sorted_list
```


### 计数排序
计数排序使用一个额外的列表，其中第i个元素是待排序列表中值等于i的元素的个数

**计数排序是一个稳定的排序算法。当输入的元素是n个0到k之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)**

适用于k不是很大且序列比较集中的列表

```py
def counting_sort(need_sorted_list: list) -> list:
    """ 计数排数 """
    temp_list = [None] * (max(need_sorted_list) + 1)
    # 将值存到对于索引中，重复时+1
    for num in need_sorted_list:
        if not temp_list[num]:
            temp_list[num] = 0
        temp_list[num] += 1

    i = 0
    # idx为值，num为值的个数，按顺序取出放回列表中
    for idx, num in enumerate(temp_list):
        while(num != None and num > 0):
            need_sorted_list[i] = idx
            num -= 1
            i += 1
    return need_sorted_list
```