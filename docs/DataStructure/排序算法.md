---
title: 排序算法
date: 2024-01-014
tags:
 - 数据结构
categories:
 - 数据结构
---


## 排序算法

### 冒泡排序
对两个相邻的元素进行比较，第一个比第二个大就进行交换，对每一个相邻的元素都进行比较，到最后的元素就会是最大的那个数

**时间复杂度（平均）O(n²)**

```py
def bubble_sort(need_sorted_list: list) -> list:
    """ 冒泡排序 """
    for i in range(len(need_sorted_list) - 1):
        for j, num1 in enumerate(need_sorted_list):
             if j < len(need_sorted_list) - 1 - i:
                 num2 = need_sorted_list[j + 1]
                 if num1 > num2:
                     temp_num = need_sorted_list[j]
                     need_sorted_list[j] = num2
                     need_sorted_list[j + 1] = temp_num
    return need_sorted_list
```

### 选择排序
将列表分类成有序区和无序区，起始的有序区为空，在列表中寻找最大（最小）的元素，将该元素加到有序区中

**时间复杂度（平均）O(n²)**
```py
def selection_sort(need_sorted_list: list) -> list:
    """ 选择排序 """
    
    # 思路实现
    ordered_list = []
    for _ in range(len(need_sorted_list)):
        max_num = max(need_sorted_list)
        need_sorted_list.remove(max_num)
        ordered_list.append(max_num)
    return ordered_list
```
```py
def selection_sort(need_sorted_list: list) -> list:
    """ 选择排序 """
   
    # 索引实现
    for i in range(len(need_sorted_list) - 1):
        min_idx = i
        for j in range(i + 1, len(need_sorted_list)):
            if need_sorted_list[j] > need_sorted_list[min_idx]:
                min_idx = j
        
        if i != min_idx:
            temp_num = need_sorted_list[i]
            need_sorted_list[i] = need_sorted_list[min_idx]
            need_sorted_list[min_idx] = temp_num
```

### 插入排序
将列表分为有序区和无序区，有序区默认拥有第一个元素，无序区为第二个以及后续的元素。每次循环在无序区中取出第一个元素j，与有序区从后往前进行比较，（从小到大排序）若小于则有序区比较的元素往后挪，直到大于或等于时，将元素j插入当前比较位置后面
**时间复杂度（平均）O(n²)**

```py
def insert_sort(need_sorted_list: list) -> list:
    """ 插入排序 """
    for i in range(1, len(need_sorted_list)):
        temp_num = need_sorted_list[i]
        cur_idx = i
        for j in range(i - 1, -1, -1):
            cur_num = need_sorted_list[j]         
            if temp_num < cur_num:
                need_sorted_list[j+1] = need_sorted_list[j]
                cur_idx = j
            else:
                break
        
        need_sorted_list[cur_idx] = temp_num
    return need_sorted_list
```
```py
def insert_sort(need_sorted_list: list) -> list:
    """ 插入排序 """
    for i in range(1, len(need_sorted_list)):
        pre_index = i - 1
        current = need_sorted_list[i]
        while(pre_index >= 0 and need_sorted_list[pre_index] > current):
            need_sorted_list[pre_index + 1] = need_sorted_list[pre_index]
            pre_index -= 1
        need_sorted_list[pre_index + 1] = current
    return need_sorted_list
```

### 希尔排序
核心思路是将排序列表分成若干个子列表分别进行插入排序
选择增量gap = len / 2, 缩小增量继续以gap = gap / 2的方式，这种增量选择我们可以用一个序列来表示{n/2, (n/2)/2, ..., 2, 1}，称为增量序列，也被称为希尔增量

**时间复杂度（平均）O(n^1.3)**

```py
def shell_sort(need_sorted_list: list) -> list:
    """ 希尔排序 """
    gap = int(len(need_sorted_list) / 2)
    while(gap > 0):
        for i in range(gap, len(need_sorted_list)):
            j = i
            temp_num = need_sorted_list[i]
            if temp_num < need_sorted_list[j - gap]:
                while ((j - gap) >= 0) and need_sorted_list[j - gap] > temp_num:
                    need_sorted_list[j] = need_sorted_list[j - gap]
                    j = j - gap
                need_sorted_list[j] = temp_num
        gap = int(gap / 2)
    return need_sorted_list
```