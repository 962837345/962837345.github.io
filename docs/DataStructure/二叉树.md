---
title: 二叉树
date: 2024-01-06
tags:
 - 数据结构
categories:
 - 数据结构
---


## 二叉树

### 二叉树的性质

1.如果二叉树的深度为K，那么该二叉树最多有（2^k-1）个节点

2.二叉树中，第i层最多有2^(i-1)个节点

3.二叉树中，叶子节点树n0，度为2的节点树n2，则n0 = n2 + 1

4.具有n个节点的满二叉树深度为log2(n+1)

### 满二叉树

二叉树中，除了叶子节点，其他节点的度都为2，则此二叉树称为满二叉树

### 完全二叉树

如果二叉树除去最后一层节点为满二叉树，且**最后一层的节点依次从左到右分布**，则此二叉树称为完全二叉树

### 二叉查找树

1.若任意节点的左子树不空，则左子树上的所有节点的值均小于它根节点的值

2.若任意节点的右子树不空，则右子树上所有节点的值均大于它根节点的值

3.任意节点的左、右子树也分别为二叉查找树

### 平衡二叉树

1. 平衡二叉树是一种二叉查找树
2. 每个节点的左子树的高度与右子树的高度差的不超过1

### 红黑树

确保最长路径不会是最短路径的两倍，当超过时就需要进行旋转（左旋、右旋）

1. 根节点是黑色的
2. 每个红色节点的两个子节点都是黑色
3. 任一节点到其每个叶子的所有路径都包含相同数量的黑色节点
4. 每个叶子节点都是黑色的

### 二叉树的遍历

#### 深度优先

##### 前序遍历

根节点->左子树->右子树

```cpp
    /**
     * 递归前序遍历
     * @param node 二叉树节点
     */
    public static void preOrderTraveral(TreeNode node){
        //节点为空则返回
        if(node == null){
            return;
        }
        //打印节点数据
        System.out.print(node.data+" ");
        preOrderTraveral(node.leftChild);
        preOrderTraveral(node.rightChild);
    }
```

##### 中序遍历

左子树->根节点->右子树

```cpp
    /**
     * 二叉树中序遍历   左-> 根-> 右
     * @param node   二叉树节点
     */
    public static void inOrderTraveral(TreeNode node){
        if(node == null){
            return;
        }
        inOrderTraveral(node.leftChild);
        System.out.print(node.data+" ");
        inOrderTraveral(node.rightChild);
    }
```

##### 后序遍历

左子树->右子树->根节点

```cpp
    /**
     * 二叉树后序遍历   左-> 右-> 根
     * @param node    二叉树节点
     */
    public static void postOrderTraveral(TreeNode node){
        if(node == null){
            return;
        }
        postOrderTraveral(node.leftChild);
        postOrderTraveral(node.rightChild);
        System.out.print(node.data+" ");
    }
```

#### 广度优先

按照二叉树的层次从上至下从左至右进行遍历

```cpp
    /**
     * 二叉树的层次遍历
     */
    public static void levelOrder(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            root = queue.poll();
            System.out.print(root.data + " ");
            if (root.leftChild != null) {
                queue.add(root.leftChild);
            }
            if (root.rightChild != null) {
                queue.add(root.rightChild);
            }
        }
    }
```

