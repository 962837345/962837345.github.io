---
title: 构造函数和析构函数
date: 2023-02-15
tags:
 - C++
categories:
 - C++
---


* 构造函数:`类名+任意参数`
* 析构函数:`~类名,不可带参数`

```cpp
#include <iostream>
#include <string>
using namespace std;

class Person 
{
public:
    int age = 0;

    Person()
    {
        cout << "这是一个无参构造函数" << endl;
    }

    Person(int age)
    {
        this->age = age;
        cout << "这是一个有参构造函数" << endl;
    }

    Person(const Person &p)
    {
        this->age = p.age;
        cout << "这是一个拷贝构造函数" << endl;
    }

    ~Person()
    {
        cout << "这是一个析构函数" << endl;
    }
};

void test()
{
    Person p1(10);
    Person p2(p1);
}

int main()
{
    test();

    system("pause");

    return 0;
}
```

:::warning

调用默认构造函数时，不要加()

因为编译器会认为这是一个函数的声明，不会认为在创建对象

`Person p1();`

:::

### 构造函数调用的三种方法

* 括号法

  ```cpp
  Person p1;
  Person p2(10);
  Person p3(p2);
  ```

* 显示法

  ```cpp
  Person p1;
  Person p2 = Person(10); // 有参构造
  Person p3 = Person(p2); // 拷贝构造
  
  Person(10); // 匿名对象
  ```

:::warning

`Person(p3);`

不要利用拷贝构造函数，初始化匿名对象。 编译器会认为`Person(p3) === Person p3`

:::

* 隐式转换法

  ```cpp
  Person p4 = 10; // 等于 Person p4 = Person(10);
  Person p5 = p4; // 拷贝构造
  ```

### 拷贝构造函数调用时机

C++中拷贝构造函数调用时机通常有三种情况

* 使用一个已创建完毕的对象来初始化一个新的对象
* 值传递的方式给函数参数传值
* 以值方式返回局部对象

```cpp
#include <iostream>
#include <string>
using namespace std;

class Person 
{
public:
    int age = 0;

    Person()
    {
        cout << "这是一个无参构造函数" << endl;
    }

    Person(int age)
    {
        this->age = age;
        cout << "这是一个有参构造函数" << endl;
    }

    Person(const Person &p)
    {
        this->age = p.age;
        cout << "这是一个拷贝构造函数" << endl;
    }

    ~Person()
    {
        cout << "这是一个析构函数" << endl;
    }
};

// 使用一个已创建完毕的对象来初始化一个新的对象
void test1()
{
    Person p1(10);
    Person p2(p1);
}

// 值传递的方式给函数参数传值
void doWork(Person p)
{

}

void test2()
{
    Person p;
    doWork(p);
}

// 以值方式返回局部对象
Person doWork3()
{
    Person p;
    return p;
}

void test3()
{
    Person p = doWork3();
}

int main()
{
    //test1();
    //test2();
    test3();

    system("pause");

    return 0;
}
```

### 构造函数的调用规则

* 创建一个类，C++编译器会给每个类都添加至少3个函数

  * 构造函数（空实现）

  * 析构函数（空实现）

  * 拷贝构造（值拷贝）

* 如果我们写了有参构造函数，编译器就不再提供默认构造，依然提供拷贝构造
* 如果我们写了拷贝构造函数，编译器就不再提供其他构造函数

### 深拷贝浅拷贝的注意项

new出来的对象是在堆中开辟一块区域，需要由程序员手动释放，拷贝构造函数如果直接拷贝赋值是一个浅拷贝的操作，会导致两个对象中的age都指向同一个地址，在p1进行析构时，由于释放掉了age这个内存，在p2析构时，就会出现错误的重复释放，导致出错。

```cpp
#include <iostream>
#include <string>
using namespace std;

class Person 
{
public:
    int* age;
    
    Person(int age)
    {
        cout << "这是一个无参构造函数" << endl;
        this->age = new int(age);
    }

    Person(const Person &p)
    {
        // this->age = p.age; // 这样赋值会导致异常，因为浅拷贝指向了同一个地址
        this->age = new int(*p.age);
        cout << "这是一个拷贝构造函数" << endl;
    }

    ~Person()
    {
        if (age != NULL)
        {
            delete age;
            age = NULL;
        }
        cout << "这是一个析构函数" << endl;
    }
};

// 使用一个已创建完毕的对象来初始化一个新的对象
void test()
{
    Person p1(10);
    
    Person p2(p1);
}


int main()
{
    test();

    system("pause");

    return 0;
}
```

