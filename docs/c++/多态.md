---
title: 多态
date: 2023-03-19
tags:
 - C++
categories:
 - C++
---

### 多态

多态分为两类：

* 静态多态：**函数重载**和**运算符重载**属于静态多态，复用函数名
* 动态多态：派生类和虚函数实现运行时多态

静态多态和动态多态的区别：

* 静态多态的函数地址早绑定 - 编译阶段确定函数地址
* 动态多态的函数地址晚绑定 - 运行阶段确定函数地址

### 纯虚函数和抽象类

在多态中，通常父类中的虚函数的实现是毫无意义的，主要都是调用子类重写的内容

因此可以将虚函数改为**纯虚函数**

纯虚函数语法：`virtual 返回值类型 函数名 (参数列表) = 0;`

当类中有了纯虚函数，这个类也称为==抽象类==

**抽象类特点**

* 无法实例化对象
* 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

### 虚析构和纯虚析构

多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码

解决方式：将父类中的析构函数改为**虚析构**或**纯虚析构**

虚析构和纯虚析构共性：

* 可以解决父类指针释放子类对象
* 都需要有具体的函数实现

虚析构和纯虚析构的区别：

* 如果时纯虚析构，该类属于抽象类，无法实例化该对象

```cpp
#include <iostream>
#include <string>
using namespace std;

class Animal
{
public:
   Animal()
   {
       cout << "Animal 构造函数调用" << endl;
   }
   ~Animal()
   {
       cout << "Animal 析构函数调用" << endl;
   }


    virtual void speak() = 0;
};

class Cat : public Animal
{
public:
    string* Name;
    Cat(string Name)
    {
        cout << "Cat 构造函数调用" << endl;
        this->Name = new string(Name);
    }

    ~Cat()
    {
        cout << "Cat 析构函数调用" << endl;
        if (Name != NULL)
        {
            delete Name;
            Name = NULL;
        }
    }

    virtual void speak()
    {
        cout << *Name << " Cat speak" << endl;
    }
};


void test()
{
    Animal *animal = new Cat("Tom");
    animal->speak();
    // 父类指针在析构时候，不会调用子类中析构函数，导致子类如果有堆区属性，会出现内存泄露
    delete animal;
}


int main()
{
    test();

    system("pause");

    return 0;
}
```

运行结果:

```cpp
Animal 构造函数调用
Cat 构造函数调用
Tom Cat speak
Animal 析构函数调用
```

将父类中的析构函数改为**虚析构**或**纯虚析构**，运行结果：

```cpp
Animal 构造函数调用
Cat 构造函数调用
Tom Cat speak
Cat 析构函数调用
Animal 析构函数调用
```

