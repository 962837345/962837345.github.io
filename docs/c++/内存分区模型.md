---
title: 内存分区模型
date: 2023-02-07
tags:
 - C++
categories:
 - C++
---


C++程序在执行时，将内存大方向划分为**4个区域**

* 代码区：存放函数体的二进制代码，由操作系统进行管理
* 全局区：存放全局变量和静态变量和常量
* 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
* 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

### 代码区

存放CPU执行的机器指令

代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可

代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令

### 全局区

全局变量和静态变量存放在此

全局区还包含了常量区，字符串常量和其他常量也存放在此

**该区域的数据在程序结束后由操作系统释放**

****

**在全局区中**

* 全局变量
* 静态变量
* static关键字
* 常量
  * 字符串常量
  * const修饰的全局变量（全局常量）

**不在全局区中**

* 局部变量
* const修饰的局部变量（局部常量）

### 栈区

由编译器自动分配释放，存放函数的参数值，局部变量等

:::warning

不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

:::

```cpp
int* func()
{
    int a = 10; // 局部变量
    return &a;	// 返回局部变量的地址
}

int main()
{
    // 接受func函数的返回值
    int * p = func();
    
    cout << *p << endl; // 第一次可以打印正确的数字，是因为编译器做了保留
    cout << *p << endl; // 第二次这个数据就不再保留了
    
    system("pause");
    
    return 0;
}
```

### 堆区

由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

在C++中主要利用**new**在堆区开辟内存

```cpp
int* func()
{
    int * a = new int(10);
    return a;
}

int main()
{
    int * p = func();
    
    cout << *p << endl;
    cout << *p << endl;
    cout << *p << endl;
    
    system("pause");
    
    return 0;
}
```

### new操作符

C++中利用**new**操作符在堆区开辟数据

堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符**delete**

利用**new**创建的数据，会返回该数据对应的类型的指针

```cpp
int* func()
{
    int * a = new int(10);
    return a;
}

int main()
{
    int * p = func();
    
    cout << *p << endl;
    cout << *p << endl;
    cout << *p << endl;
    
    delete p;
    
    cout << *p << endl; // 报错，释放的空间不可访问
    
    system("pause");
    
    return 0;
}
```

```cpp
// 开辟数组
int main()
{
    int * arr = new int(10);
    
    // 释放数组 delete 后加 []
    delete[] arr;
    
    system("pause");
    
    return 0;
}
```

