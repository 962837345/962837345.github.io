---
title: 内存分区模型
date: 2023-02-07
tags:
 - C++
categories:
 - C++
---


C++程序在执行时，将内存大方向划分为**4个区域**

* 代码区：存放函数体的二进制代码，由操作系统进行管理
* 全局区：存放全局变量和静态变量和常量
* 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
* 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

### 代码区

存放CPU执行的机器指令

代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可

代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令

### 全局区

全局变量和静态变量存放在此

全局区还包含了常量区，字符串常量和其他常量也存放在此

**该区域的数据在程序结束后由操作系统释放**

****

**在全局区中**

* 全局变量
* 静态变量
* static关键字
* 常量
  * 字符串常量
  * const修饰的全局变量（全局常量）

**不在全局区中**

* 局部变量
* const修饰的局部变量（局部常量）

### 栈区

由编译器自动分配释放，存放函数的参数值，局部变量等

:::warning

不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

:::

```cpp
int* func()
{
    int a = 10; // 局部变量
    return &a;	// 返回局部变量的地址
}

int main()
{
    // 接受func函数的返回值
    int * p = func();
    
    cout << *p << endl; // 第一次可以打印正确的数字，是因为编译器做了保留
    cout << *p << endl; // 第二次这个数据就不再保留了
    
    system("pause");
    
    return 0;
}
```

### 堆区

由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

在C++中主要利用**new**在堆区开辟内存

```cpp
int* func()
{
    int * a = new int(10);
    return a;
}

int main()
{
    int * p = func();
    
    cout << *p << endl;
    cout << *p << endl;
    cout << *p << endl;
    
    system("pause");
    
    return 0;
}
```

### new操作符

C++中利用**new**操作符在堆区开辟数据

堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符**delete**

利用**new**创建的数据，会返回该数据对应的类型的指针

```cpp
int* func()
{
    int * a = new int(10);
    return a;
}

int main()
{
    int * p = func();
    
    cout << *p << endl;
    cout << *p << endl;
    cout << *p << endl;
    
    delete p;
    
    cout << *p << endl; // 报错，释放的空间不可访问
    
    system("pause");
    
    return 0;
}
```

```cpp
// 开辟数组
int main()
{
    int * arr = new int(10);
    
    // 释放数组 delete 后加 []
    delete[] arr;
    
    system("pause");
    
    return 0;
}
```

### malloc

`void* malloc(int size);`
malloc向系统申请分配size字节的内存空间，返回类型为void*类型

```cpp
int *p;
p = (int*)malloc(sizeof(int));

free(p); //释放内存
```

### new和malloc的区别

1. new和delete是C++关键字，需要编译器支持；malloc和free是库函数，需要头文件支持

2. 使用new操作符申请内存时，无需指定内存大小，编译器会根据类型自行计算；malloc需要显示指定所需内存字节

3. new操作符内存分配成功时，返回的是对象类型的指针；malloc内存分配成功时返回的是void*，需要通过强制类型转换转换成对应的对象类型

4. new操作符会调用类型的构造函数，初始化成员变量，然后返回自定义类型的指针；而malloc只会申请内存

5. new内存分配失败时，会抛出bac_alloc异常；而malloc分配内存失败时会返回NULL