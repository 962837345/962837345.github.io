---
title: 左值与右值
date: 2024-08-19
tags:
 - C++
categories:
 - C++
---


## 左值与右值

### 左值

表达式结束后依旧存在的持久对象，可取地址

### 右值

表达式结束后就不存在的临时对象，不可取地址

如字面量（字符字面量除外）、临时的表达式值，临时的函数返回值


## 左值引用和右值引用

### 左值引用

左值引用实际就是给左值取别名，**主要作用是避免对象拷贝**

```cpp
int a = 1;
int& b = a;
```

### 左值引用的使用场景及实际意义

1. 左值引用做参数

当左值引用作为参数的时候，其效果跟利用指针作为参数的效果相当。当调用函数时，函数中的形参就会被当成实参变量或对象的一个别名使用，也就是说**函数中对形参的各种操作实际上是对实参本身操作**

2. 左值引用做返回值

```cpp
string s1("hello");

// string operator+=(char ch) 传值返回存在拷贝且是深拷贝
// string& operator+=(char ch) 左值引用做返回值没有拷贝，提高效率

s1 += '!';
```

3. 不能引用局部变量问题

* 全局变量
    
    当对象（全局变量）出了函数作用域后仍然存在，可以使用左值引用返回，这是没问题的

* 局部变量

    当对象（对象是函数内的局部对象）出了函数作用域后不存在时，就不可以使用左值引用返回值

**函数内的局部对象，出了函数作用域后就会被析构，若此时再返回该对象的左值引用，就会出问题**

**不能返回函数内部通过new分配的内存引用，如果被返回的函数的引用只是作为一个临时变量，没有将其赋值给一个实际的变量，那么就可能造成这个引用所指向的空间无法释放的情况（由于没有具体的变量名，故无法用delete手动释放该内存），从而造成内存泄漏**

### 右值引用

右值引用实际就是给右值取别名，**主要作用是延长对象的生命周期，一般是延长到作用域的scope之外**

```cpp
int fun()
{
    return 1;
}

int a = 1, b = 2;

int&& c = 10;
int&& d = a + b;
int&& e = fun();
```

对于左值引用而言，它与绑定的变量公用一块空间，是之前我们定义该变量（左值）开辟的空间

对于右值引用而言，它绑定的空间是编译器运行时为右值开辟的空间

**左值引用和右值引用都可以修改和取地址**

**右值引用**引用**右值**，会使右值被存储到特定的位置

也就是说，**右值引用变量其实是左值**，可以**对它取地址和赋值**

当然，右值引用取地址是指取变量空间的地址（右值是不能取地址的）

```cpp
int&& a = x + y;
&a;
a = 2;
```

左值引用是否可以引用右值？右值引用是否可以引用左值？

* 左值引用可以指向右值，但需要const来修饰，不能修改这个值
* 右值引用可以指向左值，需要std::move(v)即可
* 声明出来的左值引用或右值引用都是左值

### 右值引用的使用场景

主要解决**函数参数传递中（针对返回的将亡值，即局部大块数据），解决大块数据或对象的传递效率和空间不如意的问题**

```cpp

QList<Pin*> getModelPins() const
{
    QList<pin*> pins;
    for (auto& pin : m_lstPins) {
        pins << pin.data();
    }
    return str::move(pins);
}
```

## 移动语义

std::move()，作用是将一个左值强制转化为右值，以**实现移动语义**

### 移动构造

转移**参数右值**的资源来构造自己

```cpp
// 这是一个模拟string类实现的移动构造
string(string&& s):_str(nullptr), _size(0), _capacity(0)
{
    swap(s);
}
```


**拷贝构造**和**移动构造**函数都是构造函数的重载函数，不同的是：

* 拷贝构造函数的参数是**const左值引用，接收左值或右值**

* 移动构造函数的参数是**右值引用，接受右值或被move 的左值**

:::tip

当传来的参数是右值时，虽然拷贝构造函数可以接收，但是编译器会认为移动构造函数更加匹配，就会调用移动构造函数

:::

总的来说，如果这两个函数都有在类内定义的话，在构造对象时

* 若是**左值做参数，那么就会调用拷贝构造函数，做一次拷贝**（如果像string这样的在堆空间上存在资源的类），那么**每调用一次拷贝构造函数就会做一次深拷贝**

* 若是**右值做参数，那么就会调用移动构造函数，而调用移动构造函数就会减少拷贝**，（如果时像string这样在堆空间上存在资源的类），那么**每调用一次移动构造就会少做一次深拷贝**

### 移动赋值

转移**参数右值**的资源来赋给自己

```cpp
// 这是一个模拟string类的实现的移动赋值
string& operator=(string&& s)
{
    swap(s);
    return *this;
}
```

同上

* 若是**左值做参数，那么就会调用拷贝赋值，做一次拷贝**（如果像string这样的在堆空间上存在资源的类），那么**每调用一次拷贝赋值函数就会做一次深拷贝**

* 若是**右值做参数，那么就会调用移动赋值，而调用移动赋值就会减少拷贝**，（如果时像string这样在堆空间上存在资源的类），那么**每调用一次移动赋值就会少做一次深拷贝**

## 完美转发

### 引入原因（保护左值/右值属性）

在此之前我们需要知道什么是**万能引用**

确定类型的&&表示右值引用（比如 int&& string&&）

但**函数模板中的&&不表示右值引用，而是万能引用，模板类型必须通过推断才能确定**，其接收左值后会被推导为左值引用，接收右值后会被推导为右值引用

### 右值引用和万能引用的区分

```cpp
template<typename T>
class A
{
  void func(T&& t); // 模板实例化时T的类型已经确定，调用函数T是一个确定类型，所以这里是右值引用  
};
```

```cpp
template<typename T>
void f(T&& t) // 万能引用
{
    // ... 
}

int main()
{
    int a = 5; // 左值
    f(a); // 传参后被万能引用推导为左值引用

    const string s("hello"); // const左值
    f(s); // 传参后被万能引用推导为const左值引用

    f(to_string(1234)); // to_string函数会返回一个string临时对象，是右值，传参后被万能引用推导为右值引用

    const double d = 1.1;
    f(std::move(d)); // 左值引用被move后变成右值引用，传参后被万能引用推导为const右值引用

    return 0;
}

```

### 万能引用存在的问题

```cpp
#include <iostream>
using namespace std;

void Func(int& x) { cout << "左值引用" << endl; }
void Func(const int& x) { cout << "const左值引用" << endl; }
void Func(int&& x) { cout << "右值引用" << endl; }
void Func(const int&& x) { cout << "const右值引用" << endl; }

template<typename T>
void f(T&& t)
{
	Func(t);
}

int main() {
	int a = 1; // 左值
	f(a);

	const int b = 2; // const左值
	f(b);

	f(3); // 3是右值

	const int c = 4;
	f(std::move(c)); // const左值被move变成const右值

	return 0;
}
```

运行结果
```
左值引用
const左值引用
左值引用
const左值引用
```

为什么不是
```
左值引用
const左值引用
右值引用
const右值引用
```

在上面有提到**右值变量，实际是左值**，所以就有了上面的运行结果

* `f(10)`： 10是右值，传参后万能引用被推导为右值引用，但该右值引用变量其实是左值，因此实际调用的函数是`void Func(int& x)`

* `f(std::move(c))`: const左值被move后变成const右值，传参后万能引用被推导为const右值引用，但该const右值引用变量其实是const左值，因此实际调用的是`void Func(const int& x)`

也就是说，**右值引用失去了右值的属性**

但我们希望的是，**在传递过程中能保持住它原有的左值或右值属性，于是C++11标准提出完美转发**

### 完美转发概念

完美转发是指**在函数模板中，完全**依照模板的参数类型，**将参数传递给当前函数模板张的另一个函数**

因此，**为了实现完美转发，除了使用万能引用外，我们还要用到std::forward，它在传参的过程中保留对象的原生类型属性**

这样**右值引用在传递过程中就能够保持右值的属性**

```cpp
#include <iostream>
using namespace std;

void Func(int& x) { cout << "左值引用" << endl; }
void Func(const int& x) { cout << "const左值引用" << endl; }
void Func(int&& x) { cout << "右值引用" << endl; }
void Func(const int&& x) { cout << "const右值引用" << endl; }

template<typename T>
void f(T&& t)
{
	Func(std::forward<T>(t)); // 使用std::forward实现完美转发
}

int main() {
	int a = 1; // 左值
	f(a);

	const int b = 2; // const左值
	f(b);

	f(3); // 3是右值

	const int c = 4;
	f(std::move(c)); // const左值被move变成const右值

	return 0;
}
```