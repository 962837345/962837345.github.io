---
title: 模板
date: 2023-03-19
tags:
 - C++
categories:
 - C++
---

模板分为**函数模板**和**类模板**

## 函数模板

函数模板作用：

建立一个通用函数，其函数返回值类型和形参类型可以不具体指定，用一个**虚拟的类型**来代表

**语法**：

```cpp
template<typename T>
```

```cpp
#include <iostream>
#include <string>
using namespace std;

class Number
{
public:
    template<typename T>
    T add(T a, T b)
    {
        return a + b;
    }
};


void test()
{
    Number num;
    int result1 = num.add(1, 2);
    float result2 = num.add(1.0, 4.0);
    cout << "result1 = " << result1 << " result2 = " << result2 << endl;
}


int main()
{
    test();

    system("pause");

    return 0;
}
```

```cpp
result1 = 3 result2 = 5
```

注意事项：

* 自动类型推导，必须推导出一致的数据类型T，才可以使用
* 模板必须要确定出T的类型，才可以使用

### 普通函数与函数模板的区别

* 普通函数调用时可以发生自动类型转换（隐式类型转换）
* 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
* 如果利用显示指定类型的方式，可以发生隐式类型转换

### 普通函数和函数模板的调用规则

1. 如果函数模板和普通模板都可以实现，优先调用普通函数
2. 可以通过空模板参数列表来强制调用函数模板
3. 函数模板也可以发生重载
4. 如果函数模板可以产生更好的匹配，优先调用函数模板

### 模板的局限性

对于特定的数据类型无法使用通用的模板，这时可以给这种**特定类型**提供**具体化的模板**

```cpp
#include <iostream>
#include <string>
using namespace std;

class Person
{
public:
    string Name;
    int age;

    Person(string Name, int age)
    {
        this->Name = Name;
        this->age = age;
    }
};

template<class T>
bool MyCompare(T& a, T& b)
{
    return a == b;
}

template<> bool MyCompare(Person& p1, Person& p2)
{
    return (p1.Name == p2.Name && p1.age == p2.age);
}

void test()
{
    Person p1("小明", 10);
    Person p2("小明", 10);
    cout << "p1 == p2 " << MyCompare(p1, p2) << endl;
}


int main()
{
    test();

    system("pause");

    return 0;
}
```

## 类模板

类模板作用：建立一个通用类，类中的成员数据类型可以不具体指定，用一个**虚拟的类型**来代表

语法：

```cpp
template<typename T>
类
```

```cpp
#include <iostream>
#include <string>
using namespace std;

template<class NameType, class AgeType>
class Person
{
public:
    NameType Name;
    AgeType age;

    Person(NameType Name, AgeType age)
    {
        this->Name = Name;
        this->age = age;
    }
};

void test()
{ 
    // 指定具体的类型
    Person<string, int> p1("小明", 10);
    cout << "Name = " << p1.Name << " Age = " << p1.age << endl;
}


int main()
{
    test();

    system("pause");

    return 0;
}
```

### 类模板与函数模板的区别

1. 类模板没有自动类型推导
2. 类模板在模板参数列表中可以有默认参数

### 类模板中成员函数创建时机

类模板中成员函数和普通类成员函数创建时机是有区别的

* 普通类中成员函数一开始就可以创建
* 类模板中的成员函数在调用时才创建

### 类模板对象做函数参数

1. 指定传入的类型	--- 直接显示对象的数据类型
2. 参数模板化            --- 将对象中的参数变为模板进行传递
3. 整个类模板化        --- 将这个对象类型模板化进行传递

指定传入的类型

```cpp
#include <iostream>
#include <string>
using namespace std;

template<class NameType, class AgeType>
class Person
{
public:
    NameType Name;
    AgeType age;

    Person(NameType Name, AgeType age)
    {
        this->Name = Name;
        this->age = age;
    }
};

void ShowPerson(Person<string, int> &p)
{
    cout << "Name = " << p.Name << " Age = " << p.age << endl;
}

void test()
{ 
    Person<string, int> p("小明", 10);
    ShowPerson(p);
}


int main()
{
    test();

    system("pause");

    return 0;
}
```

参数模板化

```cpp
#include <iostream>
#include <string>
using namespace std;

template<class NameType, class AgeType>
class Person
{
public:
    NameType Name;
    AgeType age;

    Person(NameType Name, AgeType age)
    {
        this->Name = Name;
        this->age = age;
    }
};

template<class T1, class T2>
void ShowPerson(Person<T1, T2> &p)
{
    cout << "Name = " << p.Name << " Age = " << p.age << endl;
}

void test()
{ 
    Person<string, int> p("小明", 10);
    ShowPerson(p);
}


int main()
{
    test();

    system("pause");

    return 0;
}
```

整个类模板化

```cpp
#include <iostream>
#include <string>
using namespace std;

template<class NameType, class AgeType>
class Person
{
public:
    NameType Name;
    AgeType age;

    Person(NameType Name, AgeType age)
    {
        this->Name = Name;
        this->age = age;
    }
};

template<class T>
void ShowPerson(T &p)
{
    cout << "Name = " << p.Name << " Age = " << p.age << endl;
}

void test()
{ 
    Person<string, int> p("小明", 10);
    ShowPerson(p);
}


int main()
{
    test();

    system("pause");

    return 0;
}
```

### 类模板份文件编写

问题：

* 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到

解决：

* 解决方式1：直接包含.cpp源文件
* 解决方法2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制

### 模板函数与友元

全局函数类内实现 - 直接在类内声明友元即可

全局函数类外实现 - 需要提前让编译器知道全局函数的存在

```cpp
#include <iostream>
#include <string>
using namespace std;

// 提前让编译器知道Person类存在
template<class T1, class T2>
class Person;

// 类外实现
template<class T1, class T2>
void ShowPerson2(Person<T1, T2> p)
{
    cout << "类外实现 - Name = " << p.Name << " Age = " << p.age << endl;
}

template<class T1, class T2>
class Person
{
    // 类内实现
   friend void ShowPerson(Person<T1, T2> p)
   {
       cout << "类内实现 - Name = " << p.Name << " Age = " << p.age << endl;
   }

   // 加空模板参数列表
   // 如果全局函数 是类外实现，需要让编译器提前知道这个函数的存在
   friend void ShowPerson2<>(Person<T1, T2> p);

public:
    Person(T1 Name, T2 age)
    {
        this->Name = Name;
        this->age = age;
    }

private:
    T1 Name;
    T2 age;
};


void test()
{ 
    Person<string, int> p("小明", 10);
    ShowPerson(p);
    ShowPerson2(p);
}


int main()
{
    test();

    system("pause");

    return 0;
}
```

**通常我们使用类内实现即可，类外实现限制太多**
