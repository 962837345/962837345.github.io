---
title: 复合类型
date: 2022-04-17
tags:
 - C++
categories:
 - UE4
---

## 复合类型

### 引用

对对象起的另一个名字

定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用

引用本身并不是对象，所以不能定义引用的引用

```c++
#include <iostream>

int main()
{
    int a = 10;
    // int& refVal;     // 报错，引用必须初始化
    int &refVal = a; 
    refVal = 12;
    std::cout << a;     // 12
}
```

### 指针

对地址的封装，本身就是一个对象

* 定义指针类型的方法是将声明符写成*d的形式
* 如果一条语句中定义了几个指针变量，每个变量前面都必须加上*符号
* 和其他内置类型一样，在块作用域内定义指针如果没有初始化，将拥有一个不确定的值

```c++
int * ip1, *ip2; // ip1和ip2都是指向int型对象的指针
double *dp;
```

* 可以使用**取地址符**(操作符&)获取指针所封装的地址：

```c++
int ival = 22;
int *ip = &ival; // p是指向ival的指针
double *dp = &ival; // 错误，类型不匹配
```

* 可以使用**解引用符**(操作符*)利用指针访问对象

```c++
#include <iostream>

int main()
{
	int ival = 22;
	int* ip = &ival;
	std::cout << *ip << "\n"; // 22
	std::cout << ip;		  // 直接输出ip则打印内存中的地址:007CFE28
}
```

#### 空指针

不指向任何对象

在使用一个指针之前，应该先检查它是否为空

```c++
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL; // 需要#include cstdlib
```

#### void *指针

纯粹的地址封装，与类型无关。可以用于存放任意对象的地址

```c++
double obj = 2.22, *pd = &obj;
void *pv = &obj; // pv == pd;
```

#### 指向指针的指针

```c++
int ival = 222;
int *p1 = &ival;
int **p2 = &p1; // p2指向一个int型的指针（p2是一个指向int型指针的指针）
```

#### 指向指针的引用

指针是对象，可以定义引用

```c++
int i = 222;
int *p;
int *&r = p; // r是一个对指针p的引用

r = &i; // r引用了一个指针，这里令p指向i
*r = 0; // 解引用r得到i，也就是p指向的对象，将i的值改为0
```



