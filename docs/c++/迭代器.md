---
title: 迭代器
date: 2022-04-26
tags:
 - C++
categories:
 - C++
---


* 使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另一个元素
* 有迭代器的类型都拥有begin和end成员
  * begin：返回指向第一个元素（或字符）的迭代器
  * 尾后迭代器，即尾元素的下一个位置（一个本不存在的元素）

::: tip

`auto b = v.begin(), e = v.end();` // b和e的类型相同

如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器

:::

|              | 标准容器迭代器的运算符                                   |
| :----------: | :------------------------------------------------------- |
|    *iter     | 返回迭代器iter所指元素的引用                             |
|  iter->mem   | 解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem |
|    ++iter    | 令iter指向容器中的下一个元素（尾后迭代器除外）           |
|    --iter    | 令iter指向容器中的上一个元素                             |
| iter1==iter2 | 如果两个迭代器指向的是同一个元素则相等，否则不等         |

::: warning

尾后迭代器 并不实际指示某一个元素，所以不能对其进行递增或解引用

:::



### 迭代器类型

* 拥有迭代器的标准类型使用iterator和const_iterator（和常量指针差不多）

```cpp
vector<int>:: iterator it; // it能读写vector<int>元素
string::iterator it2;	   // it2能读写string对象中的字符

vector<int>::const_iterator it3; // it3只能读元素，不能写元素
string:const_iterator it4;		 // it4只能读元素，不能写元素
```

* 如果对象是常量，begin和end返回`const_iterator`，否则返回`iterator`

```cpp
vector<int> v;
const vector<int> cv;
auto it1 = v.begin(); // it1的类型是vector<int>::iteraotr
auto it2 = cv.begin(); // it2的类型是vector<int>::const_iterator
```

* 有时候我们希望即使对象不是常量，我们也要使用`const_iterator`:

  * c++11新标准引入了cbegin和cend

  ```cpp
  auto it3 = v.cbegin(); // it3的类型是vector<int>::const_iterator
  ```

### 结合解引用的成员访问

```cpp
vector<string> v;
auto it = v.begin();

(*it).empty();
*it.empty();  // 错误：试图访问it的名为empty的成员，it是迭代器
it->empty(); // 箭头运算符：把解引用和成员访问两个操作合在一起
```

::: warning

任何一种可能改变vector对象容器的操作，都会使得对应的迭代器失效，如在遍历时在vector对象容器后追加一个对象

:::