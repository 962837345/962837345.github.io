---
title: 深入类和对象
date: 2021-04-30
tags:
  - python
categories:
  - Python之旅
---

## 鸭子类型

### 什么是鸭子类型

当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子

也就是说，它不关注对象的类型，而是关注对象具有的行为（方法）

```py
class Cat(object):
    def say(self):
        print('I am a cat')


class Dog(object):
    def say(self):
        print('I am a Dog')


class Duck(object):
    def say(self):
        print('I am a Duck')


animals = [Cat, Dog, Duck]
for animal in animals:
    animal().say()

# I am a cat
# I am a Dog
# I am a Duck
```

Cat、Dog、Duck 中有相同的方法 say()，当有一个函数调用 Duck()类时并调用 say()方法，我们传入 Cat 类和 Dog 类也可以调用，函数不会检查对象是不是 Duck，而是只要有这样的方法就行

```py
a = [1, 2, 3]
b = (4, 5, 6)
c = set()
c.add(7)
c.add(8)
c.add(9)
a.extend(b)
print(a)
a.extend(c)
print(a)
# [1, 2, 3, 4, 5, 6]
# [1, 2, 3, 4, 5, 6, 8, 9, 7]
```

列表的`extend()`方法只要参数是一个可迭代的对象就可以（list, set, tuple 等等）

Python 中的鸭子类型允许我们使用任何提供所需方法的对象，而不需要迫使它成为一个子类

### 多态

由于 python 属于动态语言，当你定义了一个基类和基类中的方法，并编写几个继承该基类的子类时，由于 python 在定义变量时不指定变量的类型，而是由解释器根据变量内容推断变量类型（也就是说变量的类型取决于所关联的对象），这就使得 python 的多态不像`c++`或`java`中那样，定义一个基类类型变量而隐藏了具体子类的细节

## 抽象基类(abc 模块)

### 在某些情况下判断某个对象的类型

```py
from collections.abc import Sized


class Company(object):
    def __init__(self, employee_list):
        self.employee_list = employee_list

    def __len__(self):
        return len(self.employee_list)


com = Company(['1,2,3'])
print(isinstance(com, Sized))  # True
```

### 强制某个子类必须实现某些方法

设计一个抽象基类，指定子类必须实现某些方法

```py
class CacheBase():
    def get(self, key):
		pass

    def set(self, key, value):
        pass
```

### 模拟抽象基类

#### 利用内置抛错模拟

```py
class CacheBase():
    def get(self, key):
        # 默认抛出异常(python内置错误)
        raise NotImplementedError

    def set(self, key, value):
        raise NotImplementedError


cachebase = CacheBase()
cachebase.set('key', 'value')

# raise NotImplementedError
```

```py
class CacheBase():
    def get(self, key):
        # 默认抛出异常(python内置错误)
        raise NotImplementedError

    def set(self, key, value):
        raise NotImplementedError

# 继承重写就不会抛异常
class RedisCache(CacheBase):
    def get(self, key):
        pass

    def set(self, key, value):
        pass


cachebase = RedisCache()
cachebase.set('key', 'value')
```

#### 利用内置的 abc 模块

```py
import abc


class CacheBase(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def get(self, key):
        # 默认抛出异常(python内置错误)
        raise NotImplementedError

    @abc.abstractmethod
    def set(self, key, value):
        raise NotImplementedError


class RedisCache(CacheBase):
    pass


redisCache = RedisCache()
# TypeError: Can't instantiate abstract class RedisCache with abstract methods get, set
```

#### 通用的抽象基类（collections.abc 模块，推荐使用多继承 mixin，以防抽象过度设计）

可遍历、可哈希的等等抽象基类，这些抽象基类都有一个魔法函数`__subclasshook__()`

`Company()`没有继承`Sized`,但是却能判断出是`Sized`类型

`__subclasshook__()`会判断传入的 C 是否有`__len__`这个方法，有就返回`True`

```py
class Sized(metaclass=ABCMeta):

    __slots__ = ()

    @abstractmethod
    def __len__(self):
        return 0

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Sized:
            return _check_methods(C, "__len__")
        return NotImplemented
```

```py
from collections.abc import Sized


class Company():
    def __init__(self, em_list):
        self.em_list = em_list

    def __len__(self):
        return len(self.em_list)


company = Company([1, 2, 3])
# 判断是否有某个方法
print(hasattr(company, '__len__'))  # True
# 利用抽象基类Sized判断
print(isinstance(company, Sized))  # True
```

## 使用`isinstance`而不是`type`

`isinstance`内部会检查它的继承链，就可以判断它是 A 的类型，而`type`是指向 B 那个对象，判断是否和 B 是同一个对象。尽量使用`isinstance`,而不是 type

```py
class A():
    pass


class B(A):
    pass


b = B()
print(isinstance(b, A))  # True
print(type(b) is B)  # True
print(type(b) is A)  # False
```

**is 和==**

`is`是判断两者是不是一个对象（即 id 是否相同），而`==`是判断值是否相同。如`type(b)`指向的是 B 这个对象，虽然 B 继承 A，但是 A 和 B 是两个不同的对象

## 类变量和对象变量

魔法函数`__init__`中`self`实例化对象，实例化后调用变量是向上查找（先查找对象变量，后查找类变量），类变量可以直接通过类访问

```py
class A():
    aa = 1

    def __init__(self, x, y):
        self.x = x
        self.y = y


a = A(2, 3)
# A.aa会修改类变量
A.aa = 11
# a.aa是在对象a上新建一个变量aa=100
a.aa = 100
# 优先查找到对象本身的变量aa
print(a.x, a.y, a.aa) # 2 3 100
print(A.aa) # 11
```

## 类属性和实例属性以及查找顺序

**1. 向上查找，即先查找对象变量（实例属性），后查找类属性**

**2. 多继承采用 MRO（【Method Resolution Order】： 方法解析顺序）算法**

python 语言包含了很多优秀的特性，其中多重继承就是其中之一，但是多重继承会引发很多问题，比如二义性，Python 中一切皆引用，这使得它不会像 C++一样使用虚基类处理基类对象重复的问题，但是如果父类存在同名函数的时候还是会产生二义性，Python 中处理这种问题的方法就是 MRO

**3. C3 算法**

**4. 查找顺序**

- 菱形继承，使用广度优先进行查找

  ```py
  # 菱形继承
  class D:
      pass


  class C(D):
      pass


  class B(D):
      pass


  class A(B, C):
      pass


  print(A.__mro__)
  # (<class '__main__.A'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.D'>, <class 'object'>)
  ```

- 分别继承，使用深度优先进行查找

  ```py
  # 分别继承
  class E:
      pass


  class D:
      pass


  class C(E):
      pass


  class B(D):
      pass


  class A(B, C):
      pass


  print(A.__mro__)
  # (<class '__main__.A'>, <class '__main__.B'>, <class '__main__.D'>, <class '__main__.C'>, <class '__main__.E'>, <class 'object'>)
  ```

## 静态方法、类方法以及对象方法

### 实例方法：self 为实例对象

```py
class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    def tomorrow(self):
        self.day += 1

    def __str__(self):
        return "{year}/{month}/{day}".format(year=self.year,
                                             month=self.month,
                                             day=self.day)


new_day = Date(2021, 5, 1)
# 相当于tomorrow(new_day)
new_day.tomorrow()
print(new_day)  # 2021/5/2
```

### 静态方法：（相当于普通的函数）

:::tip

采用硬编码，如果类名改变，相应的静态方法中也要改变。如下面的 Date 改变，则 parse_from_string 中 Date 也相应改变

:::

```py
class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    def tomorrow(self):
        self.day += 1

    def __str__(self):
        return "{year}/{month}/{day}".format(year=self.year,
                                             month=self.month,
                                             day=self.day)


date_str = "2021-5-1"
year, month, day = tuple(date_str.split('-'))
new_day = Date(int(year), int(month), int(day))
print(new_day)  # 2021/5/1
```

```py
class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    def tomorrow(self):
        self.day += 1

    # 利用静态方法处理
    @staticmethod
    def parse_from_string(date_str):
        year, month, day = tuple(date_str.split('-'))
        return Date(int(year), int(month), int(day))

    def __str__(self):
        return "{year}/{month}/{day}".format(year=self.year,
                                             month=self.month,
                                             day=self.day)


date_str = "2021-5-1"
new_day = Date.parse_from_string(date_str)
print(new_day)  # 2021/5/1
```

**静态方法用处：如在判断传入的参数是否为合法字符串，此时不用返回类对象，因此不用传入类（类方法）**

### 类方法（传递的是类 cls）

:::tip

相比静态方法，不是采用硬编码，无论类名是什么，都不用修改类方法，且传递的是类（cls，只是名称，可以修改）

:::

:::tip

`self`和`cls`只是一个默认规定使用的名称，都可以修改，`self`指代的是类实例,`cls`指代的是类本身

:::

```py
class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    def tomorrow(self):
        self.day += 1

    # 利用静态方法处理
    @staticmethod
    def parse_from_string(date_str):
        year, month, day = tuple(date_str.split('-'))
        return Date(int(year), int(month), int(day))

    # 利用类方法，则不管类名称是什么都不用修改
    @classmethod
    def from_string(cls, date_str):
        year, month, day = tuple(date_str.split('-'))
        return cls(int(year), int(month), int(day))

    def __str__(self):
        return "{year}/{month}/{day}".format(year=self.year,
                                             month=self.month,
                                             day=self.day)


date_str = "2021-5-1"
new_day = Date.from_string(date_str)
print(new_day)  # 2021/5/1
```

## 数据封装和私有属性

### 私有属性

python 中类的私有属性是在属性前面加双下划线，进行私有属性封装

```py
class User:
    def __init__(self, name):
        self.__name = name


user = User('xiaoming')
print(user.__name)
# AttributeError: 'User' object has no attribute '__name'
```

无法通过实例或类直接访问私有属性，只能通过类中的公共方法间接访问

### 私有属性原理

把具有双下划线的属性（如**name 变为`\_classname**attr`即`\_User\_\_name`)，因此不是从语言层面解决了绝对私有性，只是加了一些小技巧。主要只是让我们书写更加规范，没有绝对的安全，也可以解决同样的变量名冲突的问题。如另一个类继承User，且也有`\_name`，则根据规则是不一样的

## python 对象的自省机制

### 概念

自省是通过一定的机制查询到对象的内部结构

### `__dict__`、`dir`的使用

#### 通过`__dict__`查找属性

```py
class User:
    name = 'user'


class Student(User):
    def __init__(self, school):
        self.school = school


stu = Student('哈哈')
print(stu.__dict__)
print(stu.name)
# {'school': '哈哈'}
# user
```

`__dict__`没有`name`，但是`name`属性却能查找到（向上查找，`name`属于`User`这个类）

#### 通过`__dict__`添加修改属性

```py
class User:
    name = 'user'


class Student(User):
    def __init__(self, school):
        self.school = school


stu = Student('哈哈')
print(stu.__dict__)
stu.__dict__['address'] = "广州"
print(stu.address)
# {'school': '哈哈'}
# 广州
```

#### 通过`dir`查找属性（会列出所有属性，比`__dict__`更加详细）

```py
class User:
    name = 'user'


class Student(User):
    def __init__(self, school):
        self.school = school


stu = Student('哈哈')
print(dir(stu))
# ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name', 'school']
```

## super 函数

子类想调用父类中的函数，可以使用`super()`进行调用

调用 super 函数可以很好的重用代码，如某个参数需要父类的构造函数处理，就可以调用 super 函数把参数交给父类的构造函数处理

**super 函数并不是直接调用父类，而是根据 MRO 算法的调用顺序**

```py
class A:
    def __init__(self):
        print('A')


class B(A):
    def __init__(self):
        print('B')
        super().__init__()


class C(A):
    def __init__(self):
        print('C')
        super().__init__()


class D(B, C):
    def __init__(self):
        print('D')
        super().__init__()


d = D()
print(D.__mro__)

# D
# B
# C
# A
# (<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)
```

## 多继承使用的经验

### 建议

尽量不要使用多继承，以免造成混乱

### mixin 多继承案例

- mixin 类功能单一
- 不和基类关联，可以和任意基类组合，基类可以不和 mixin 关联就能初始化成功
- 在 mixin 中不要使用 super 函数
- 尽量以 Mixin 结尾

## python 中的 with 语句

### try...except 语句

except 语句中将 2 压入堆栈中，finally 又将 4 压入堆栈中，所以在取数据时直接从栈顶取数据，因此是 4，如果没有 finally 则是前面的 2（如果要操作数据库、文件等，就需要在 try、except、finally 中书写关闭连接，文件的逻辑）

```py
def exe_test():
    try:
        print('start')
        raise KeyError
        return 1
    except KeyError as e:
        print('key error')
        return 2
    else:
        print('other error')
        return 3
    finally:
        print('finally')
        return 4


result = exe_test()
print(result)

# start
# key error
# finally
# 4
```

### 上下文管理器

**上下文管理器协议（需要实现两个魔法函数`__enter__`和`__exit__`）**

需要在`__enter__`中获取资源，在`__exit__`中释放资源，只要满足这个协议就可以用`with`语句

```py
class A:
    def __enter__(self):
        print('enter')
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print('exit')

    def do_something(self):
        print('do_something')


with A() as a:
    a.do_something()

# enter
# do_something
# exit
```

## contextlib 实现上下文管理器

相当于简化`__enter`和`__exit__`：`@contextlib.contextmanager`装饰器将`__enter`和`__exit__`合起来并进行了一系列操作

```py
import contextlib


@contextlib.contextmanager
def file_open(file_name):
    # yeild之前的操作相当于__enter__里的操作
    print('file open')
    yield
    # yeild之后的相当于__exit__里的操作
    print('file end')


with file_open('my.txt') as f:
    print('file reading')

# file open
# file reading
# file end
```
