---
title: 元类编程
date: 2021-05-13
tags:
  - python
categories:
  - Python之旅
---

## property动态属性

**@property:可以直接像属性那样访问，只是取数据（相当于get），可以加入自己的逻辑**

**@name.setter:赋值（相当于set）**

```py
from datetime import datetime, date


class User():
    def __init__(self, name, birthday):
        self.name = name
        self.birthday = birthday
        self._age = 0

    # 函数的方式获取
    def get_age(self):
        return datetime.now().year - self.birthday.year

    @property
    def age(self):
        return datetime.now().year - self.birthday.year

    @age.setter
    def age(self, value):
        self._age = value


user = User('kellen', date(year=1998, month=3, day=20))
user.age = 18
print(user._age)  # 18
print(user.age)  # 23
```

## `__getattr__`、`__getattribute__`魔法函数

### `__getattr__`

查找不到属性的时候调用

```py
from datetime import date


class User():
    def __init__(self, name, birthday):
        self.name = name
        self.birthday = birthday

    def __getattr__(self, item):
        return 'not found attr'


user = User("kellen", date(year=1998, month=3, day=20))
# 查找不到age,进入__getattr__魔法函数
print(user.age)  # not found attr
```

```py
from datetime import date


class User():
    def __init__(self, info):
        self.info = info

    def __getattr__(self, item):
        return self.info[item]


user = User(info={"name": "kellen", "age": 23})
print(user.name)  # kellen
print(user.age)  # 23
```

### `__getattribute__`

`__getattribute__`比`__getattr__`更优先，无条件进入，不管能否找到（尽量不重写）

```py
from datetime import date


class User():
    def __init__(self, name, info):
        self.name = name
        self.info = info

    def __getattr__(self, item):
        return self.info[item]

    def __getattribute__(self, item):
        return '拿到了'


user = User(name="kellen", info={"name": "kellen", "age": 23})
print(user.name)  # 拿到了
print(user.test)  # 拿到了
```

## `__new__`和`__init__`的区别

`__new__`传递的参数是类，是在生成对象的过程中调用，而`__init__`传递的是对象，是在生成对象后调用(`__new__`是在`__init__`之前的)

```py
class User:
    def __new__(cls, *args, **kwargs):
        print('new')
        # 返回才会调用__init__
        return super().__new__(cls)

    def __init__(self):
        print('init')


user = User()

# new
# init
```

:::tip

1. `__new__`是用来控制对象的生成过程的，在对象生成之前
2. `__init__`是用来完善对象的
3. 如果`__new__`不返回对象，则不会调用`__init__`方法
4. 传递的参数需要在`__init__`中接收
5. 继承自object的新式类才有`__new__`
6. `__new__`至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别
7. `__new__`必须要有返回值，返回实例化出来的实例，或者直接是object的`__new__`出来的实例
8. `__init__`有一个参数self，就是这个`__new__`返回的实例,`__init__`在`__new__`的基础上可以完成一些其他初始化的动作，`__init__`不需要返回值
9. 如果`__new__`创建的是当前类的实例，会自动调用`__init__`函数，通过return语句里面调用的`__new__`函数的第一个参数是cls来保证是当前类实例，如果是其他类的类名，那么实际创建返回的就是其他类的实例，其实就不会调用当前类的`__init__`函数，也不会调用其他类的`__init__`函数

:::

## 属性描述符和属性查找过程

1. **前言：在类中，如果需要限制属性的类型**

   **如果用动态属性来验证（如果验证name和_age都是字符串），就需要写多个动态属性验证（代码重复度高，而且多）**

2. **属性描述符：只需要实现（`__get__`,`__set__`,`__delete__`）中任意一个方法就是属性描述符**

   2.1 **介绍：**

   ​		描述符的本质是新式类，并且被代理的类（即应用描述符的类）也是新式类。描述符的作用是用来代理一个类的属性，需要注意的是描述符不能定义在类的构造函数中，只能定义为类的属性，它只属于类，不属于实例，我们通过查看实例和类的字典即可知晓。描述符是可以实现大部分Python类特性中最底层的数据结构的实现手段，我们常使用的`@classmethod`、`@staticmethod`、`@property`、甚至是`__slots__`等属性，都是通过描述符来实现的。它是很多高级库和框架的重要工具之一，是使用到装饰器或者元类的大型框架中的一个非常重要组件。在一般的开发中我们可能用不到描述符，但是我们想要开发一个大型的框架或者大型的系统，那使用描述符回起到如虎添翼的作用。它的加盟会使得系统更加完美。下面将简单介绍描述符的使用。

   2.2 **分类：**

   ​		**数据描述符**

   ​				至少实现了内置属性`__set__()`和`__get__()`方法的描述符称为数据描述符

   ​		**非数据描述符**

   ​				实现了除`__set__()`以外的方法的描述符称为非数据描述符

   2.3 **优先级:**

   ​		之所以要区分描述符的种类，主要是因为它在代理类属性时有着严格的优先级限制。例如当使用数据描述符时，因为数据描述符大于实例属性，所以当我们实例化一个类并使用该实例属性时，该实例属性已经被数据描述符代理，此时我们对该实例属性的操作是对描述符的操作。描述符的优先级高低如下：

   ​		**类属性 > 数据描述符 > 实例属性 > 非数据描述符 > 找不到的属性触发`__getattr__()`**

   2.4 **示例：**

   ```py
   import numbers
   
   
   class IntField:
       # 只需要实现以下任意一个方法就行（就能制定成属性描述符）
       def __get__(self, instance, owner):
           # 保持和__set__中一样(value)
           return self.value
   
       def __set__(self, instance, value):
           if not isinstance(value, numbers.Integral):
               raise ValueError('int value error')
           if value < 0:
               raise ValueError('positive value error')
           self.value = value
   
       def __delete__(self, instance):
           pass
   
   
   class User:
       age = IntField()
   
   
   if __name__ == '__main__':
       user = User()
       # 调用__set__验证成功
       user.age = 6
   
       print(user.age)
       # 字符串抛出错误
       user.age = 'abc'
   ```

3. **属性查找过程**

   如果user是某个类的实例，那么`user.age`(以及等价的`getattr(user, 'age')`)

   首先调用`__getattribute__`。如果类定义了`__getattr__`方法，那么在`__getattribute__`抛出AttributeError的时候就会调用到`__getattr__`

   而对于描述符(`__get__`)的调用，则是发生在`__getattribute__`内部的

   `user = User()`，那么`user.age`顺序如下

   (1) 如果`age`是出现在`User`类或者其基类的`__dict__`中，且`age`是data descriptor，那么调用其`__get__`方法,否则

   (2) 如果`age`出现在`user`对象的`__dict__`中，那么直接返回`obj.__dict__['age']`，否则

   (3) 如果`age`出现在`User`或其基类的`__dict__`中
   (3.1) 如果age是non-data descriptor,那么调用其`__get__`,否则

   (3.2) 返回`__dict__['age']`

   (4) 如果`User`有`__getattr__`方法，调用`__getattr__`方法，否则

   (5) 抛出AttributeError

   ```py
   import numbers
   
   
   class IntField:
       # 只需要实现以下任意一个方法就行（就能制定成属性描述符）
       def __get__(self, instance, owner):
           # 保持和__set__中一样(value)
           return self.value
   
       def __set__(self, instance, value):
           if not isinstance(value, numbers.Integral):
               raise ValueError('int value error')
           if value < 0:
               raise ValueError('positive value error')
           self.value = value
   
       def __delete__(self, instance):
           pass
   
   
   class NonDataIntField:
       # 非数据属性描述符
       def __get__(self, instance, owner):
           return self.value
   
   
   class User:
       age = IntField()
   
       # age = NonDataIntField()
   
   if __name__ == '__main__':
       user = User()
       # 调用__set__验证成功
       user.age = 6
   
       print(user.age)
       # 字符串抛出错误
       user.age = 'abc'
   ```

   **3.1 数据描述符，进入类User的`__dict__`中**

   ```py
   import numbers
   
   
   class IntField:
       # 只需要实现以下任意一个方法就行（就能制定成属性描述符）
       def __get__(self, instance, owner):
           # 保持和__set__中一样(value)
           return self.value
   
       def __set__(self, instance, value):
           if not isinstance(value, numbers.Integral):
               raise ValueError('int value error')
           if value < 0:
               raise ValueError('positive value error')
           self.value = value
   
       def __delete__(self, instance):
           pass
   
   
   class NonDataIntField:
       # 非数据属性描述符
       def __get__(self, instance, owner):
           return self.value
   
   
   class User:
       age = IntField()
   
       # age = NonDataIntField()
   
   
   if __name__ == '__main__':
       user = User()
       # 调用__set__验证成功
       user.age = 6
       # age是数据描述符，age没有进入到user的__dict__中，进入的是User类中的__dict__
       print(user.__dict__)  # {}
       print(getattr(user, 'age'))  # 6
   ```

    **3.2 非数据描述符**

   ```py
   import numbers
   
   
   class IntField:
       # 只需要实现以下任意一个方法就行（就能制定成属性描述符）
       def __get__(self, instance, owner):
           # 保持和__set__中一样(value)
           return self.value
   
       def __set__(self, instance, value):
           if not isinstance(value, numbers.Integral):
               raise ValueError('int value error')
           if value < 0:
               raise ValueError('positive value error')
           self.value = value
   
       def __delete__(self, instance):
           pass
   
   
   class NonDataIntField:
       # 非数据属性描述符
       def __get__(self, instance, owner):
           return self.value
   
   
   class User:
       # age = IntField()
   
       age = NonDataIntField()
   
   
   if __name__ == '__main__':
       user = User()
       # 调用__set__验证成功
       user.age = 6
       # 非数据描述符，age进入到user的__dict__中
       print(user.__dict__)  # {'age': 6}
       print(getattr(user, 'age'))  # 6
   ```

   **3.3 获取类中数据描述符失败**

   ```py
   import numbers
   
   
   class IntField:
       # 只需要实现以下任意一个方法就行（就能制定成属性描述符）
       def __get__(self, instance, owner):
           # 保持和__set__中一样(value)
           return self.value
   
       def __set__(self, instance, value):
           if not isinstance(value, numbers.Integral):
               raise ValueError('int value error')
           if value < 0:
               raise ValueError('positive value error')
           self.value = value
   
       def __delete__(self, instance):
           pass
   
   
   class NonDataIntField:
       # 非数据属性描述符
       def __get__(self, instance, owner):
           return self.value
   
   
   class User:
       age = IntField()
   
       # age = NonDataIntField()
   
   
   if __name__ == '__main__':
       user = User()
       # 直接对实例添加属性
       user.__dict__['age'] = 'haha'
       # 用__dict__就和属性查找过程没有关系了
       print(user.__dict__)  # {'age': 'haha'}
       # 会抛错，age是数据属性描述符，首先进入类中调用属性，__get__返回value，但是没有这个值
       print(user.age)
   ```