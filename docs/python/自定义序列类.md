---
title: 自定义序列类
date: 2021-05-07
tags:
  - python
categories:
  - Python之旅
---

## 序列类型的分类

1. 容器序列（可以在容器中放置任意类型的数据）

   list、tuple、deque

2. 扁平序列

   str、bytes、bytearray、array.array（区别于list，只能存储同一类型数据）

3. 可变序列

   list、deque、bytearray、array

4. 不可变序列

   str、tuple、bytes

## 序列的+、+=和extend的区别

`+`只能是同一类型（如列表），`+=`就地加，不产生新序列，且参数可以为任意的序列类型，是通过魔法函数`__iadd__`实现的，`extend`也可以添加任意序列类型

```py
a = [1, 2]
a += (3, 4)

print(a)  # [1, 2, 3, 4]

a.extend((5, 6))

print(a)  # [1, 2, 3, 4, 5, 6]
```

## 实现可切片的对象

### 切片用法

```py
# 模式[start:end:step]
"""
    其中，第一个数值start表示切片开始位置，默认为0
    第二个数字end表示切片截止（但不包含）位置（默认为列表长度）
    第三个数字step表示切片的步长（默认为1）
    当start为0时可以省略，当end为列表长度时可以省略
    当step为1时可以省略，并且省略步长时可以同时省略最后一个冒号
    另外，当setp为负整数时，表示反向切片，这时start应该比end的值要大才行
"""

aList = [1, 2, 3, 4, 5]
print(aList[::])  # 返回包含原列表中所有元素的新列表
print(aList[::-1])  # 返回包含原列表中所有元素的逆序列表
print(aList[::2])  # 隔一个取一个，获取偶数位置的元素
print(aList[1::2])  # 隔一个取一个，获取奇数位置的元素
print(aList[2:4])  # 指定切片的开始和结束位置
print(aList[0:100])  # 切片结束位置大于列表长度时，从列表尾部截断
print(aList[100:1])  # 切片开始位置大于列表长度时，返回空列表

aList[len(aList):] = [9]  # 在列表尾部增加元素
aList[:0] = [1, 2]  # 在列表头部插入元素
aList[3:3] = [4]  # 在列表中间位置插入元素
aList[:1] = [5, 6]  # 替换列表元素
aList[3:] = [4, 5, 6]  # 替换列表元素
aList[::2] = [0] * 3  # 隔一个修改一个
print(aList)

aList[::2] = ['a', 'b', 'c']  # 隔一个修改一个
# aList[::2] = [1, 2]  # 左侧切片不连续，等号两边列表长度必须相等
aList[:3] = []  # 删除列表中前3个元素

del aList[:3]  # 切片元素连续
del aList[::2]  # 切片元素不连续，隔一个删一个
print(aList)
```

### 实现可切片对象

```py
import numbers


class Group:
    def __init__(self, company_name, group_name, staff):
        self.company_name = company_name
        self.group_name = group_name
        self.staff = staff

    def __reversed__(self):
        self.staff.reverse()

    def __getitem__(self, item):
        # 实现该魔法函数就能实现切片操作
        cls = type(self)
        if isinstance(item, slice):
            # 传入的数据是切片类型时[0:2]
            return cls(company_name=self.company_name,
                       group_name=self.group_name,
                       staff=self.staff[item])
        elif isinstance(item, numbers.Integral):
            return cls(company_name=self.company_name,
                       group_name=self.group_name,
                       staff=[self.staff[item]])

    def __len__(self):
        return len(self.staff)

    def __iter__(self):
        return iter(self.staff)

    def __contains__(self, item):
        # 是否包含某条数据
        if item in self.staff:
            return True
        else:
            return False


staff = ['1', '2', '3']
group = Group('haha', 'heihei', staff=staff)
sub_group1 = group[0:2]
sub_group2 = group[0]
# 调用__len__
print(len(group))
# 调用__contains__
print('1' in group)
# 调用__iter__
for num in group:
    print('iter遍历' + str(num))
# 调用__reverse__
reversed(group)

# 3
# True
# iter遍历1
# iter遍历2
# iter遍历3
```

## bisect关联可排序序列

bisect用来处理已排序的序列，用来维持已排序的序列，升序（性能高）

采用二分查找，性能非常高

```py
import bisect

list = []
bisect.insort(list, 1)
bisect.insort(list, 4)
bisect.insort(list, 2)
bisect.insort(list, 5)
bisect.insort(list, 3)
bisect.insort(list, 6)

print(list)  # [1, 2, 3, 4, 5, 6]
```

