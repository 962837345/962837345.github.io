---
title: 迭代器和生成器
date: 2021-05-30
tags:
  - python
categories:
  - Python之旅
---

## python的迭代协议

1. **什么是迭代器**

   迭代器是访问集合内数据的一种方式，一般是用来遍历数据的

2. **迭代器和以下标访问的方式不一样，迭代器是不能返回的，且迭代器提供了一种惰性访问数据的方式**

3. **python中可迭代的对象基本都是实现了`__iter__`魔法函数的，迭代协议实质上就是满足`__iter__`魔法函数**

```py
from collections.abc import Iterable, Iterator

a = [1, 2]

print(isinstance(a, Iterable))  # True
print(isinstance(a, Iterator))  # False
```

## 什么是迭代器和可迭代对象

1. **可迭代和迭代器的区别**

   ```py
   from collections.abc import Iterable, Iterator
   
   a = [1, 2]
   
   iter_rator = iter(a)
   print(isinstance(a, Iterable))  # True
   print(isinstance(a, Iterator))  # False
   print(isinstance(iter_rator, Iterable))  # True
   print(isinstance(iter_rator, Iterator))  # True
   ```

2. **`__iter__`和`__getitem__`**

   ```py
   class Company(object):
       def __init__(self, emplyee_list):
           self.emplyee_list = emplyee_list
   
       # def __iter__(self):
       #     return 1
   
       def __getitem__(self, item):
           return self.emplyee_list[item]
   
   
   if __name__ == '__main__':
       com = Company(['a', 'b', 'c'])
       # 内部实质也是iter，首先调用__iter__(如果有),否则调用__getitem__
       for i in com:
           print(i)
   ```

3. **自己实现迭代器**

   ```py
   from collections.abc import Iterator
   
   
   class Company(object):
       def __init__(self, employee_list):
           self.employee_list = employee_list
   
       def __iter__(self):
           return MyIterator(self.employee_list)
   
   
   class MyIterator(Iterator):
       def __init__(self, emp_list):
           self.iter_list = emp_list
           self.index = 0
   
       def __next__(self):
           try:
               word = self.iter_list[self.index]
           except IndexError:
               raise StopIteration
           self.index += 1
           return word
   
   
   if __name__ == '__main__':
       com = Company(['a', 'b', 'c'])
       my_iter = iter(com)
       # for循环内部其实也是调用next方法
       while True:
           try:
               print(next(my_iter))
           except StopIteration:
               pass
   ```

## 生成器函数使用

1. **什么是生成器函数：函数里面只要有yield关键字**

   生成器函数返回的是一个生成器对象，是在python编译字节码的时候就产生了

   return只能有一个返回值，而yield可以返回多个，生成器对象实现了迭代协议

   惰性求值，延迟求值提供了可能性

   ```py
   def gen_func():
       # 首先把值返回会调用方
       # 然后又调用__next__调用下一个（实现了生成器协议）
       yield 'a'
       yield 'b'
   
   
   def func():
       return 1
   
   
   c1 = gen_func()
   c2 = func()
   print(c1)  # <generator object gen_func at 0x000001FF950BEB30>
   for i in c1:
       print(i)  # a b
   
   print(c2)  # 1
   ```

   使用生成器实现斐波那契数列

   ```py
   def gen_fib(index):
       n, a, b = 0, 0, 1
       while n < index:
           yield b
           a, b = b, a + b
           n += 1
   
   
   for i in gen_fib(10):
       print(i)
   
   # 1 1 2 3 5 8 13 21 34 55
   ```

## 生成器实现大文件读取

```py
# 读取大文件
def myreadlines(f, newline):
    # buf相当于缓存
    buf = ""
    while True:
        while newline in buf:
            pos = buf.index(newline)
            yield buf[:pos]
            # 更新截断buf（以分隔符）
            buf = buf[pos + len(newline):]

        # 每次读取4096个字符（接着上一次的）
        chunk = f.read(4096)

        if not chunk:
            # 说明已经读到了文件结尾
            yield buf
            break
        buf += chunk


with open("input.txt") as f:
    for line in myreadlines(f, "{|}"):
        print(line)
```





