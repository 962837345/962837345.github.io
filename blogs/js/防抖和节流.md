---
title: 防抖和节流
date: 2020-07-19
tages:
 - JS
categories:
 - 前端笔记
---

## 防抖
### 抖动案例

假设我们的一个输入框，输入内容的同时可能会去后台查询对应的联想词，
如果用户输入的同时，频繁的触发input事件，然后频繁的向后台发送请求，
那么直到用户输入完成时，之前的请求都应该是多余的，假设网络慢一点，
后台返回的数据比较慢，那么显示的联想词可能会出现频繁的变换，直到最后的一个请求返回。

### 防抖应用场景
* 输入框中频繁的输入内容，搜索或者提交信息
* 频繁的点击按钮，触发某个事件
* 监听浏览器滚动事件，完成某些特定操作
* 用户缩放浏览器的resize事件

### 防抖代码
每一次事件被触发，都会清除当前的timer，并重新设置超时调用，
这样导致每一次高频事件都会导致后一个调用取消前一个调用，只有当高频事件不触发，
最后一次事件触发的超时调用才能在delay时间后执行 

```js
export function debounce(func, delay = 500) {
  let timer = null;
  return function (...args) {
    if (timer) clearTimeout(timer);

    timer = setTimeout(() => {
      func.apply(this, args)
    }, delay)
  }
}
```

## 节流
节流是另一种处理类似问题的方法

节流允许一个函数在规定事件内只执行一次

它和防抖动最大的区别就是，节流函数不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数。

### 节流应用场景
* 监听页面的滚动事件
* 鼠标移动事件
* 用户频繁点击按钮操作
* 游戏中的一些设计

### 节流代码

```js
export function throttle(fn, interval) {
  let last = 0;
  
  return function() {
    let _this = this;
    let _arguments = arguments;
    
    let now = new Date().getTime();
    if(now - last > interval){
      fn.apply(_this, _arguments);
      last = now;
    }
  }
}
```