(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{514:function(t,e,a){"use strict";a.r(e);var s=a(4),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"核心思想-发布-订阅模式（观察者模式）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心思想-发布-订阅模式（观察者模式）"}},[t._v("#")]),t._v(" 核心思想——发布/订阅模式（观察者模式）")]),t._v(" "),a("p",[t._v("vue的响应式原理是当把一个普通的JavaScript对象传入Vue实例作为"),a("code",[t._v("data")]),t._v("选项，\nVue 将遍历此对象所有的 property，并使用 "),a("code",[t._v("Object.defineProperty")]),t._v("把这些 property 全部转为 "),a("code",[t._v("getter/setter")]),t._v(",\n这就是进行数据劫持或数据代理")]),t._v(" "),a("p",[t._v("每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。\n之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。")]),t._v(" "),a("p",[t._v("Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，\n所以 property 必须在 "),a("code",[t._v("data")]),t._v(" 对象上存在才能让 Vue 将它转换为响应式")]),t._v(" "),a("p",[t._v("对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，\n可以使用"),a("code",[t._v("Vue.set(object, propertyName, value)")]),t._v(" 方法向嵌套对象添加响应式 property")]),t._v(" "),a("h2",{attrs:{id:"vue-不能检测以下数组的变动"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-不能检测以下数组的变动"}},[t._v("#")]),t._v(" Vue 不能检测以下数组的变动")]),t._v(" "),a("p",[t._v("1.当你利用索引直接设置一个数组项时，例如："),a("code",[t._v("vm.items[indexOfItem]")]),t._v(" = newValue")]),t._v(" "),a("p",[t._v("2.当你修改数组的长度时，例如：vm.items.length = newLength")]),t._v(" "),a("p",[t._v("解决方案：")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("$"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("items"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" indexOfItem"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" newValue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("items"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("splice")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("newLength"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("h2",{attrs:{id:"异步更新队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步更新队列"}},[t._v("#")]),t._v(" 异步更新队列")]),t._v(" "),a("p",[t._v("Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，\n并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次")]),t._v(" "),a("p",[t._v("可以在数据变化之后使用"),a("code",[t._v("Vue.nextTick(callback)")]),t._v("，这样回调函数将会在DOM更新完后被调用，\n回调函数返回的是一个Promise实例")]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("外界通过watcher读取数据时，会触发getter从而将watcher添加到依赖中")]),t._v(" "),a("p",[t._v("在修改对象的值的时候，会触发对应的setter，setter通知之前依赖收集得到每一个watcher，通知它们进行update操作")])])}),[],!1,null,null,null);e.default=r.exports}}]);