(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{567:function(t,v,i){"use strict";i.r(v);var l=i(6),s=Object(l.a)({},(function(){var t=this,v=t.$createElement,i=t._self._c||v;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h2",{attrs:{id:"浏览器渲染过程"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染过程"}},[t._v("#")]),t._v(" 浏览器渲染过程")]),t._v(" "),i("p",[t._v("1.构建DOM树")]),t._v(" "),i("p",[t._v("当浏览器客户端从服务器那里接收到HTML文档后，就会遍历文档节点然后生成DOM树，DOM树结构和HTML标签一一对应")]),t._v(" "),i("div",{staticClass:"custom-block tip"},[i("p",{staticClass:"title"}),i("ul",[i("li",[t._v("DOM树在构建过程中可能会被CSS和JS的加载而执行阻塞")]),t._v(" "),i("li",[t._v("display：none的元素也会在DOM树中")]),t._v(" "),i("li",[t._v("注释也会在DOM树中")]),t._v(" "),i("li",[t._v("script标签会在DOM树中")])])]),i("p",[t._v("2.CSS解析")]),t._v(" "),i("p",[t._v("浏览器会解析CSS文件并生成CSS规则树，在过程中，每个CSS文件都会被分析成StyleSheet对象，每个对象都包括CSS规则，\nCSS规则对象包括对应的选择器和声明对象以及其他对象")]),t._v(" "),i("div",{staticClass:"custom-block tip"},[i("p",{staticClass:"title"}),i("ul",[i("li",[t._v("CSS解析可以与DOM解析同进行")]),t._v(" "),i("li",[t._v("CSS解析与script的执行互斥")]),t._v(" "),i("li",[t._v("在Webkit内核中进行了script执行优化，只有在JS访问CSS时才会发生互斥")])])]),i("p",[t._v("3.构建渲染树（Render tree）")]),t._v(" "),i("p",[t._v("通过DOM树和CSS规则树，浏览器就可以通过它两构建渲染树了。浏览器会先从DOM树的根节点开始遍历每个可见节点，然后对每个可见节点找到适配的CSS样式规则并应用")]),t._v(" "),i("div",{staticClass:"custom-block tip"},[i("p",{staticClass:"title"}),i("ul",[i("li",[t._v("渲染树和DOM树不完全对应")]),t._v(" "),i("li",[t._v("display：none的元素不在渲染树中")]),t._v(" "),i("li",[t._v("visibility：hidden的元素在渲染树中")])])]),i("p",[t._v("4.渲染树布局")]),t._v(" "),i("p",[t._v("布局阶段会从渲染树的根节点开始遍历，由于渲染树每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式\n信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，布局阶段的输出就是我们常说的\n盒子模型，它会精确地捕获每个元素在屏幕内的确切位置和大小")]),t._v(" "),i("div",{staticClass:"custom-block tip"},[i("p",{staticClass:"title"}),i("ul",[i("li",[t._v("float元素、absolute元素、fixed元素会发生位置偏移")]),t._v(" "),i("li",[t._v("我们常说的脱离文档流，其实就是脱离Render Tree")])])]),i("p",[t._v("5.渲染树绘制")]),t._v(" "),i("p",[t._v("在绘制阶段，浏览器会遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的")]),t._v(" "),i("h3",{attrs:{id:"阻塞渲染的两种情况"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#阻塞渲染的两种情况"}},[t._v("#")]),t._v(" 阻塞渲染的两种情况")]),t._v(" "),i("p",[t._v("当HTML解析器被脚本阻塞时，解析器虽然会停止构建DOM，但仍然会辨识该脚本后面的资源，并进行预加载")]),t._v(" "),i("ul",[i("li",[t._v("JS不仅可以读取和修改DOM属性，还可以读取和修改CSSOM属性，因此CSS解析与script的执行互斥，这就导致了浏览器在遇到\nscript标签时，DOM构建将暂停，直至脚本完成执行，然后继续构建DOM。如果脚本是外部的，会等待脚本下载完毕，在继续解析\n文档,这就是JS阻塞页面。")])]),t._v(" "),i("div",{staticClass:"custom-block tip"},[i("p",{staticClass:"title"}),i("ul",[i("li",[i("p",[t._v("可以在script标签上增加defer或者async属性，脚本解析会将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM树和CSSOM\n规则树上")])]),t._v(" "),i("li",[i("p",[t._v("多个defer会按照声明顺序加载，defer是立即下载但延迟执行，defer会在DOMContentLoaded之前执行")])]),t._v(" "),i("li",[i("p",[t._v("多个async不会按照声明顺序加载并执行，async立即下载且执行")])])])]),i("ul",[i("li",[t._v("由于CSSOM负责存储渲染信息，浏览器就必须保证在合成渲染树之前，CSSOM是完备的，这种完备是指所有的CSS（内联、内部和外部）都已经下载完，并解析完。只有CSSOM和DOM解析完全结束，浏览器才会进入下一步的渲染，这就是CSS阻塞渲染")])]),t._v(" "),i("h2",{attrs:{id:"浏览器输入url到页面加载全过程"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#浏览器输入url到页面加载全过程"}},[t._v("#")]),t._v(" 浏览器输入url到页面加载全过程")]),t._v(" "),i("ol",[i("li",[t._v("浏览器查找当前URL是否存在缓存，并比较缓存是否过期")]),t._v(" "),i("li",[t._v("DNS解析URL对应的IP")]),t._v(" "),i("li",[t._v("根据IP建立TCP连接（三次握手）")]),t._v(" "),i("li",[t._v("HTTP发起请求")]),t._v(" "),i("li",[t._v("服务器处理请求，浏览器接收HTTP响应")]),t._v(" "),i("li",[t._v("渲染页面，构建DOM树")]),t._v(" "),i("li",[t._v("关闭TCP连接（四次挥手）")])])])}),[],!1,null,null,null);v.default=s.exports}}]);